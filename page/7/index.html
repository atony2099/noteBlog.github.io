<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="托尼的开发笔记">
<meta property="og:url" content="atony2099.github.io/page/7/index.html">
<meta property="og:site_name" content="托尼的开发笔记">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="托尼的开发笔记">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="atony2099.github.io/page/7/"/>





  <title> 托尼的开发笔记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">托尼的开发笔记</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/10/12/UI再认识/事件响应链/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/12/UI再认识/事件响应链/" itemprop="url">
                  事件响应链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-12T22:27:40+08:00">
                2015-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="RUNLoop"><a href="#RUNLoop" class="headerlink" title="RUNLoop"></a>RUNLoop</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-19/23126752-file_1484839778038_1059c.png" alt=""></p>
<p>Runloop注册一个source1接受系统事件，</p>
<ol>
<li>当系统产生事件，通过mach port 转发给当前的app进程，</li>
<li>事件被包装成UIEvent.,加入ApplicationHandleEventQueue(待处理队列) </li>
<li>由Application 从队列里面取出事件分发给UIWindow, </li>
<li>UIWindow调用[hitTest:withEvent:]递归找出hit-test view。</li>
<li>UIWindow将事件发送给hit-test view</li>
</ol>
<h4 id="Hit-Testing"><a href="#Hit-Testing" class="headerlink" title="Hit-Testing"></a>Hit-Testing</h4><blockquote>
<p> iOS uses hit-testing to find the view that is under a touch. Hit-testing involves checking whether a touch is within the bounds of any relevant view objects. If it is, it recursively checks all of that view’s subviews. The lowest view in the view hierarchy that contains the touch point becomes the <em>hit-test view</em>. After iOS determines the hit-test view, it passes the touch event to that view for handling. </p>
</blockquote>
<p><img src="http://zhoon.github.io/img/artical/ios_event/iosevent_5.png" alt=""></p>
<p>相关实现代码猜想:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 什么时候调用:只要事件一传递给一个控件，那么这个控件就会调用自己的这个方法</span><br><span class="line">// 作用:寻找并返回最合适的view</span><br><span class="line">// UIApplication -&gt; [UIWindow hitTest:withEvent:]寻找最合适的view告诉系统</span><br><span class="line">// point:当前手指触摸的点</span><br><span class="line">// point:是方法调用者坐标系上的点</span><br><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">      // 1.判断下窗口能否接收事件</span><br><span class="line">       if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha &lt;= 0.01) return nil; </span><br><span class="line">      // 2.判断下点在不在窗口上 </span><br><span class="line">      // 不在窗口上 </span><br><span class="line">      if ([self pointInside:point withEvent:event] == NO) return nil; </span><br><span class="line">      // 3.从后往前遍历子控件数组 </span><br><span class="line">      int count = (int)self.subviews.count; </span><br><span class="line">      for (int i = count - 1; i &gt;= 0; i--)     &#123; </span><br><span class="line">      // 获取子控件</span><br><span class="line">      UIView *childView = self.subviews[i]; </span><br><span class="line">      // 坐标系的转换,把窗口上的点转换为子控件上的点 </span><br><span class="line">      // 把自己控件上的点转换成子控件上的点 </span><br><span class="line">      CGPoint childP = [self convertPoint:point toView:childView]; </span><br><span class="line">      UIView *fitView = [childView hitTest:childP withEvent:event]; </span><br><span class="line">      if (fitView) &#123;</span><br><span class="line">      // 如果能找到最合适的view </span><br><span class="line">     	 return fitView; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    // 4.没有找到更合适的view，也就是没有比自己更合适的view </span><br><span class="line">    return self;</span><br><span class="line">    &#125;</span><br><span class="line">    @end</span><br></pre></td></tr></table></figure>
<h4 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h4><h5 id="The-Responder-Chain-响应链"><a href="#The-Responder-Chain-响应链" class="headerlink" title="The Responder Chain  响应链"></a>The Responder Chain  响应链</h5><p><strong>the  Responder Chain  is made up of responder object;</strong></p>
<blockquote>
<p>If the initial object—either the hit-test view or the first responder—doesn’t handle an event, UIKit passes the event to the next responder in the chain. Each responder decides whether it wants to handle the event or pass it along to its own next responder by calling the <code>nextResponder</code> method.This process continues until a responder object either handles the event or there are no more responders.</p>
<p>关于 doesn’t handle an event的理解</p>
<p>UIResponder里面touch四个阶段的方法里面，如果当前view没有重写并做相关处理，默认就向上转发给父view</p>
</blockquote>
<p><img src="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt=""></p>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-20/79432745-file_1484845234056_102d5.jpg" alt=""></p>
<p>UIApplication中有个sendEvent:的方法，在UIWindow中同样也可以发现一个同样的方法。UIApplication是通过这个方法把事件发送给UIWindow，然后UIWindow通过同样的接口，把事件发送给hit-testview</p>
<h4 id="应用–扩大按钮的点击区域"><a href="#应用–扩大按钮的点击区域" class="headerlink" title="应用–扩大按钮的点击区域"></a>应用–扩大按钮的点击区域</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event&#123;</span><br><span class="line">    CGRect bounds = self.bounds;</span><br><span class="line">    //若原热区小于44x44，则放大热区，否则保持原大小不变</span><br><span class="line">    CGFloat widthDelta = MAX(44.0 - bounds.size.width, 0);</span><br><span class="line">    CGFloat heightDelta = MAX(44.0 - bounds.size.height, 0);</span><br><span class="line">    bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);</span><br><span class="line">    return CGRectContainsPoint(bounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="external">Event Delivery: The Responder Chain</a></p>
<p><a href="深入浅出iOS事件机制">http://zhoon.github.io/ios/2015/04/12/ios-event.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/09/19/函数式编程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/19/函数式编程/" itemprop="url">
                  函数式编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-19T14:36:32+08:00">
                2015-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>####概念</p>
<blockquote>
<p>函数式编程是一种编程规范，也就是如何编写方程的方法论，主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式。</p>
<p>　　(1 + 2) * 3 - 4</p>
</blockquote>
<p>传统的过程式编程，可能这样写：</p>
<blockquote>
<p>　　var a = 1 + 2;</p>
<p>　　var b = a * 3;</p>
<p>　　var c = b - 4;</p>
</blockquote>
<p>函数式编程要求使用函数，我们可以把运算过程<a href="http://lostechies.com/derickbailey/2012/01/24/some-thoughts-on-functional-javascript/" target="_blank" rel="external">定义</a>为不同的函数，然后写成下面这样：</p>
<blockquote>
<p>　　var result = subtract(multiply(add(1,2), 3), 4);</p>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>函数式编程具有五个鲜明的特点。</p>
<p><strong>1. 函数是”第一等公民”</strong></p>
<p>所谓<a href="http://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="external">“第一等公民”</a>（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p>
<blockquote>
<p>　　var print = function(i){ console.log(i);};<br>　　[1,2,3].forEach(print);</p>
</blockquote>
<p><strong>2. 只用”表达式”，不用”语句”</strong></p>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>
<p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p>
<p>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p>
<p><strong>3. 没有”副作用”</strong></p>
<p>所谓<a href="http://en.wikipedia.org/wiki/Side_effect_(computer_science" target="_blank" rel="external">“副作用”</a>)（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>
<p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>
<p><strong>4. 不修改状态</strong></p>
<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
<p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的”状态”。</p>
<blockquote>
<p>　　function reverse(string) {</p>
<p>　　　　if(string.length == 0) {</p>
<p>　　　　　　return string;</p>
<p>　　　　} else {</p>
<p>　　　　　　return reverse(string.substring(1, string.length)) + string.substring(0, 1);</p>
<p>　　　　}</p>
<p>　　}</p>
</blockquote>
<p>由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。</p>
<p><strong>5. 引用透明</strong></p>
<p>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p>
<p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>函数式编程到底有什么好处，为什么会变得越来越流行？</p>
<p><strong>1. 代码简洁，开发快速</strong></p>
<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
<p>Paul Graham在<a href="http://www.ruanyifeng.com/docs/pg/" target="_blank" rel="external">《黑客与画家》</a>一书中<a href="http://www.ruanyifeng.com/blog/2010/10/why_lisp_is_superior.html" target="_blank" rel="external">写道</a>：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。</p>
<p>如果程序员每天所写的代码行数基本相同，这就意味着，”C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。”当然，这样的对比故意夸大了差异，但是”在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。”</p>
<p><strong>2. 接近自然语言，易于理解</strong></p>
<p>函数式编程的自由度很高，可以写出很接近自然语言的代码。</p>
<p>前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：</p>
<blockquote>
<p>　　subtract(multiply(add(1,2), 3), 4)</p>
</blockquote>
<p>对它进行变形，不难得到另一种写法：</p>
<blockquote>
<p>　　add(1,2).multiply(3).subtract(4)</p>
</blockquote>
<p>这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：</p>
<blockquote>
<p>　　merge([1,2],[3,4]).sort().search(“2”)</p>
</blockquote>
<p><strong>参考</strong></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程初探</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/09/12/1内存管理/autoreleasepool/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/12/1内存管理/autoreleasepool/" itemprop="url">
                  autorelesePool
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-09-12T20:18:02+08:00">
                2015-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="autoreleasePool的实现原理"><a href="#autoreleasePool的实现原理" class="headerlink" title="autoreleasePool的实现原理"></a>autoreleasePool的实现原理</h4><ol>
<li>autoreleasePool是由若干个AutoreleasePoolPage以双向链表组成， 每一个线程的 autoreleasepool 按堆栈的方式存储对象的指针，id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置<ul>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
<li>每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个`哨兵对象，值为0（也就是个nil）,并从哨兵对象对象对象位置开始存储指针</li>
</ul>
</li>
</ol>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/66532911-file_1484604072733_11269.jpg" alt=""></p>
<ol>
<li>objc_autoreleasePoolPush的返回值正是这个哨兵对象的地址，被objc_autoreleasePoolPop(哨兵对象)作为入参，于是：<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置<br><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/52002764-file_1484604072858_134b7.jpg" alt=""></li>
</ul>
</li>
</ol>
<h4 id="autoreleased-对象的释放时机"><a href="#autoreleased-对象的释放时机" class="headerlink" title="autoreleased 对象的释放时机"></a>autoreleased 对象的释放时机</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/32208599-file_1484656781760_283c.gif" alt=""></p>
<p> 在每一个runloop周期内，runloop 都会创建一个autoreleasepool，在runloop即将休眠 drain 这个pool</p>
<p>autoreleased对象此时被释放</p>
<h4 id="autoreleasepool-使用场景"><a href="#autoreleasepool-使用场景" class="headerlink" title="autoreleasepool 使用场景"></a>autoreleasepool 使用场景</h4><ol>
<li><p>If you write a loop that creates many temporary objects.</p>
<p>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application</p>
<blockquote>
<p>个人理解: 如果在短时间创建了大量autoreleased对象，内存会迅速增加，但是autoreleased对象要等待本次runloop周期结束后才释放，这时候可以手动创建autoreleasepool池即时释放</p>
</blockquote>
<p>​</p>
</li>
<li><p>If you spawn a secondary thread.</p>
<p>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.</p>
<blockquote>
<p>个人理解: 在实际开发中，我们最长使用时GCD和NSOperation,在两个框架下，会自动帮我们构建autoreleasepool，所以即使没有显示调用autoreleasepool，也不一定会造成很大的内存泄露问题,</p>
</blockquote>
<p>参考stack overflow：</p>
<p><a href="http://stackoverflow.com/questions/4141123/do-you-need-to-create-an-nsautoreleasepool-within-a-block-in-gcd" target="_blank" rel="external">Do you need to create an NSAutoreleasePool within a block in GCD?</a></p>
<blockquote>
<p>If your block creates more than a few Objective-C objects, you might want to enclose parts of your block’s code in an @autorelease block to handle the memory management for those objects. Although GCD dispatch queues have their own autorelease pools, they make no guarantees as to when those pools are drained. If your application is memory constrained, creating your own autorelease pool allows you to free up the memory for autoreleased objects at more regular intervals.</p>
</blockquote>
<p>​</p>
</li>
</ol>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Using Autorelease Pool Blocks</a></p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/08/08/其他-实际开发问题/navigationBar/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/08/其他-实际开发问题/navigationBar/" itemprop="url">
                  UINavigationBar
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-08-08T19:30:25+08:00">
                2015-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://ohbzayk4i.bkt.clouddn.com/16-12-18/79131915-file_1482024380487_ccf5.jpg" alt=""></p>
<blockquote>
<p>The UINavigationBar class provides a control for navigating hierarchical content. It’s a bar, typically displayed at the top of the screen, containing buttons for navigating within a hierarchy of screens. The primary properties are a left (back) button, a center title, and an optional right button. You can use a navigation bar as a standalone object or in conjunction with a navigation controller object.</p>
<p>A UINavigationItem object manages the buttons and views to be displayed in a UINavigationBar object. When building a navigation interface, each view controller pushed onto the navigation stack must have a UINavigationItem object that contains the buttons and views it wants displayed in the navigation bar. The managing UINavigationController object uses the navigation items of the topmost two view controllers to populate the navigation bar with content.</p>
<p>如果把导航控制器比作一个剧院，那导航栏就相当于舞台，舞台必然是属于剧院的，所以，导航栏是导航控制器的一个属性。视图控制器（UIViewController）就相当于一个个剧团，而导航项（navigation item）就相当于每个剧团的负责人，负责与剧院的人接洽沟通。显然，导航项应该是视图控制器的一个属性。虽然导航栏和导航项都在做与导航相关的事情，但是它们的从属是不同的。  </p>
</blockquote>
<p><a href="http://www.jianshu.com/p/f797793d683f" target="_blank" rel="external">【iOS】导航栏那些事儿</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/08/03/1多线程编程/进程和线程理解/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/03/1多线程编程/进程和线程理解/" itemprop="url">
                  进程和线程理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-08-03T15:13:11+08:00">
                2015-08
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://ifeve.com/context-switch-definition/" target="_blank" rel="external">上下文切换详解</a></p>
<p><a href="http://www.cnblogs.com/CareySon/archive/2012/05/04/ProcessAndThread.html" target="_blank" rel="external">操作系统中的进程与线程</a></p>
<p><a href="http://www.embedu.org/Column/Column240.htm" target="_blank" rel="external">对Linux内核中进程上下文和中断上下文的理解</a></p>
<p><a href="http://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="external">编程思想之多线程与多进程(1)——以操作系统的角度述说线程与进程</a></p>
<h4 id="理解进程"><a href="#理解进程" class="headerlink" title="理解进程"></a>理解进程</h4><p><img src="http://img.blog.csdn.net/20150623201226625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>大部分操作系统任务调度是采用时间片轮转的抢占式调度方式，一个任务执行一段时间后强制停止停止切换到下一个任务,同一时间点只执行一个任务，时间片的切换非常短，给人的感觉多个任务在同时执行，这也就是人们通常说的<strong>并发</strong></p>
<p>早期的操作系统并没有线程的概念，任务调度的基本单位就是<strong>进程</strong>，进程就是拥有资源和执行任务的基本单位</p>
<p>进程由代码，数据集合和进程控制块三部分组成，描述一个具有独立功能的程序的程序的一次执行过程</p>
<blockquote>
<p>由于采用时间片轮转的调度方式，进程在执行一段时间后必须进行切换，执行切换的时候，需要保持当前进程的状态，寄存器的值，堆栈内容， 以便下次改进程被重新执行后恢复，这一过程叫做进程的上下文切换，由于进程上下文切换开销很大，线程应运而生</p>
</blockquote>
<h5 id="线程-vs-进程"><a href="#线程-vs-进程" class="headerlink" title="线程 vs 进程"></a>线程 vs 进程</h5><p>线程也叫轻量级进程((Lightweight Process)，一个进程由多个线程组成，线程是进程中代码不同的执行路径</p>
<p>进程：有独立的内存空间(代码，数据，进程空间，打开的文件)。</p>
<p>线程：共享进程空间,cpu调度的基本单位</p>
<p><img src="http://img.blog.csdn.net/20150623201304175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHVvd2VpZnU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h5 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h5><p>某一时间点，寄存器的值，进程的状态，堆栈中的内容就是进程的上下文</p>
<p>当发生进程调度时，进程切换就是上下文切换</p>
<p>进程= cup 加载 上下文 + cpu执行 + cpu保持上下文(到内存中)</p>
<p>在内存中检索一个进程的上下文并将其在cpu的寄存器恢复</p>
<p>跳转到程序计数器的值，并恢复该进程</p>
<p>挂起一个进程，将改进程的上下文存储于内存的某处</p>
<table>
<thead>
<tr>
<th>进程占有的资源</th>
<th>线程占有的资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址空间 全局变量 打开的文件 子进程 信号量 账户信息</td>
<td>栈 寄存器 状态 程序计数器</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/07/29/计算机基础知识/编程常见名词集锦/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/29/计算机基础知识/编程常见名词集锦/" itemprop="url">
                  编程常见名词集锦
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-29T19:48:20+08:00">
                2015-07
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>计算机语言添加某种语法，这种语法对语言的功能并没有影响，但是更方便<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98" target="_blank" rel="external">程序员</a>使用。语法糖让程序更加简洁，有更高的可读性。</p>
<blockquote>
<p>举例来说，许多程序语言提供专门的语法来对数组中的元素进行引用和更新。从理论上来讲，一个数组元素的引用涉及到两个参数：数组和下标向量，比如这样的表达式，get_array(Array, vector(i, j))。然而，许多语言支持这样直接引用 Array[i, j]。同理，数组元素的更新涉及到三个参数，set_array(Array, vector(i, j), value)，但是很多语言提供这样直接赋值，Array[i, j] = value。</p>
</blockquote>
<p>语言处理器，包括编译器和静态分析器，在处理的过程中，首先把“加糖”的结构变成基本的结构，这个过程叫做“去糖”。</p>
<blockquote>
<p>简要认识:语法糖只是为了方便程序员使用，并没有在语言里面添加新的东西，编译器会帮我们做转换</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/04/28/APP启动过程探究/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/28/APP启动过程探究/" itemprop="url">
                  APP启动过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-04-28T22:05:59+08:00">
                2015-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文探讨的问题？</p>
<ul>
<li>应用程序的启动过程是怎么样？</li>
<li>应用程序的生命周期是怎么样？</li>
</ul>
<h4 id="应用程序的启动过程"><a href="#应用程序的启动过程" class="headerlink" title="应用程序的启动过程"></a>应用程序的启动过程</h4><p><img src="http://oleb.net/media/xcode-4-2-app-launch-sequence.png" alt=""></p>
<p><em>图片来源外国网友</em></p>
<p>上图比较完整的描绘一个app启动过程，让我们一步一步开始分解</p>
<ul>
<li>main函数执行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数是程序的入口，app启动时候先执行main函数，main函数再调用UIApplicationMain函数，</p>
<ul>
<li><p>UIApplicationMain函数这做了很多事情，首先他会创建一个UIAPPlication的单例对象，并创建UIApplication对象的代理对象AppDelegate</p>
<blockquote>
<p>苹果已经为把每个应用包装成一个UIApplication对象，但应用每一步运行的细节并不需要开发者关注，只要关注这个应用对象对应的delegate即可，也就是这个“AppDelegate”。通过AppDelegate我们可以知道Application的运行状态，发生了哪些事件。</p>
<p>The <code>UIApplicationDelegate</code> protocol defines methods that are called by the singleton <code>UIApplication</code> object in response to important events in the lifetime of your app.</p>
<p>AppDelegate定义了很多app生命周期中的重要事件</p>
</blockquote>
<p>同时他会载入和解析info.plist文件.</p>
<blockquote>
<p>info.plist是对工程运行期配置的文件，info常见字段有： </p>
<p>   1&gt; Localiztion native development region (CFBundleDevelopmentRegion)-本地化相关;</p>
<pre><code>2&gt; Bundle display name(CFBundleDisplayName)-程序安装后显示的名称,限制在10-12个字符,如果超出,将被显示缩写名称;

3&gt; Icon file(CFBundleIconFile)-app图标名称,一般为Icon.png;

4&gt; Bundle version(CFBundleVersion)-应用程序的版本号,每次往App Store上发布一个新版本时,需要增加这个版本号;

5&gt; Main storyboard file base name(NSMainStoryboardFile)-主storyboard文件名称;

6&gt; Bundle identifier(CFBundleIdentifier)-项目的唯一标识,部署到真机时用到;
</code></pre></blockquote>
</li>
</ul>
<ul>
<li><p>UIApplication 对象创建管理runloop，UIApplication对象通过runloop来处理各种事件，runloop是一个无限循环，使UIApplicationMain()永远不返回</p>
</li>
<li><p>在UIApplication 对象开始处理事件之前，它会给它的代理发送一个消息application:didFinishLaunchingWithOptions:告诉代理对象AppDelegate，程序已经启动.</p>
<p>如果之前info.plist没有指定main stroyboard，这时候我们就需要在该方法里面手动创建keyWindow并设置它的rootViewController，相关代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    self.viewController = [[ViewController alloc] initWithNibName:@&quot;ViewController&quot; bundle:nil];</span><br><span class="line">    self.window.rootViewController = self.viewController;</span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="应用程序的生命周期"><a href="#应用程序的生命周期" class="headerlink" title="应用程序的生命周期"></a>应用程序的生命周期</h4><p>应用程序的状态大概如下: </p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th>运行机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Not Runing</td>
<td>程序没有启动</td>
</tr>
<tr>
<td style="text-align:left">Inactive</td>
<td>过渡的状态，或者被系统打断(短信，电话), ，应用程序不接收消息或事件</td>
</tr>
<tr>
<td style="text-align:left">Active</td>
<td>前台运行的正常状态,能够接收消息和事件</td>
</tr>
<tr>
<td style="text-align:left">Background</td>
<td>进入后台的状态，不会停留太久就会进如挂起状态</td>
</tr>
<tr>
<td style="text-align:left">suspended</td>
<td>程序在暂停时不能执行代码、但是不会被释放内存。但是当系统内存不足的情况下，暂停的程序有可能会被释放。</td>
</tr>
</tbody>
</table>
<p><img src="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Art/app_interruptions_2x.png" alt=""></p>
<p>初次启动：</p>
<p><code>applicationdidFinishLaunchingWithOptions</code><br><code>applicationDidBecomeActive</code></p>
<p>按下home键：</p>
<p><code>applicationWillResignActive</code><br><code>applicationDidEnterBackground</code></p>
<p><code>applicationWillTerminate</code> // 即将推出</p>
<p>点击APP重新进入：</p>
<p><code>applicationWillEnterForeground</code><br><code>applicationDidBecomeActive</code></p>
<p>参考文档: </p>
<p><a href="http://blog.csdn.net/yang8456211/article/details/11662891" target="_blank" rel="external">iOS application生命周期研究、发现与总结</a></p>
<p><a href="http://oleb.net/blog/2012/02/app-launch-sequence-ios-revisited/" target="_blank" rel="external">Revisiting the App Launch Sequence on iOS</a></p>
<p><a href="http://www.molotang.com/articles/1254.html" target="_blank" rel="external">iOS应用程序的状态及其切换（生命周期)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/03/12/计算机基础知识/面向对象/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/12/计算机基础知识/面向对象/" itemprop="url">
                  聚合与耦合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-12T22:27:40+08:00">
                2015-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文来源: <a href="http://www.nowamagic.net/program/program_PolymerizationAndCoupling.php" target="_blank" rel="external">面向对象编程中的聚合与耦合</a> </p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><blockquote>
<p>聚合（Cohesion）是一个模块内部各成分之间相关联程度的度量。</p>
</blockquote>
<p>这里有多个含义值得考虑。首先，聚合是对一个模块内部的度量，这也是许多情况下我们把聚合称之为内聚的原因。第二，这里出现的模块是广义的模块，它可能是子系统，可能是功能模块，也可能是功能模块中的某一个类。从不同的层次看，聚合的程度也会有所不同。至于为什么不同，后面会有解释。第三，模块的成分包括模块的行为和状态。要做到高聚合，那么模块内部的行为必须要与模块的内部状态紧密关联。通俗来讲，<strong>一个模块仅完成一个独立的功能，模块内部不存在与该功能无关的操作或状态。</strong></p>
<p>举一个生活中的例子。</p>
<p>有两座城市Sidtown和Fredborough，连接两座城市的公路一天到晚总是拥堵不堪。经过”有关部门”调查之后发现，这两座城市中有两家公司Better Mousetrap和 Zokko Soda，Better Mousetrap的工厂建造在Sidtown,而该工厂的员工都居住在Fredborough,所以每天早上大批员工从Fredborough出发前往Sidtown，并在傍晚返回；类似的，Zokko Soda公司的运输车在每天的工作时间都需要在制瓶工厂和灌装工厂穿梭来往。</p>
<p><img src="http://img.blog.csdn.net/20140326234013250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVtaXo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>很明显，如果Better Mousetrap的工厂和员工居住地都在同一城市，而Zokko Soda的两座工厂都建造在另一座城市，那么城市之间的交通状况将会明显改善。</p>
<p><img src="http://img.blog.csdn.net/20140326234049875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVtaXo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>对比两图，上面两座城市间之所以出现交通的问题，是因为每座城市的”聚合性”都比较低：不相关的两个公司出现在了同一座城市，使得城市内部交通的利用率比较低，而城市之间的交通出现了超负荷。</p>
<h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><blockquote>
<p>耦合（Couping）是模块之间相关联程度的度量</p>
</blockquote>
<p>相对于聚合的内向性，耦合关注的是某一模块和其他模块之间的关联性。其实从前面的例子里，我们已经不可避免的提到了耦合的问题：由于两座城市之间的相互联系过于紧密，导致了城市之间的交通拥堵。另外一个潜在的问题就是，如果其中一座城市内部的交通出现了问题，另一座城市也会受到影响。<strong>我们所追求的低耦合，就是将两个模块之间的关联尽可能的降低，一个模块发生变化对于其他模块的影响尽可能的小</strong>。</p>
<p>再讲一个生活中的例子，相信大部分的80后小的时候都玩过一种掌上游戏机，这种游戏机内含一个俄罗斯方块的游戏。这种游戏机虽然风靡一时，但是不多久就渐渐淡出了市场，因为这种游戏机只有俄罗斯方块可以玩儿，当我们玩儿腻了的时候，这个游戏机也就如同废物一个了。</p>
<p>同期，任天堂推出一款后来风靡了将近20年的红白机，这种游戏机市场寿命如此之长并非游戏机本身质量有多好，而是因为基于红白机开发的游戏层出不穷，经典无数。魂斗罗、超级玛丽在当时哪怕是现在也是无人不知。红白机的游戏本身并不存储在游戏机当中，每当有新游戏推出的时候，只需要购买新的卡带即可。正是这种游戏机和卡带相对独立的设计，使得游戏的设计厂商无需关心游戏机的实现细节，只要遵循游戏机提供的接口（插槽）。很多游戏的设计厂商也从红白机庞大的市场中分得一杯羹。大多数的玩家可能不知道，魂斗罗并非任天堂推出的产品，而是目前以《实况足球》系列闻名世界的KONAMI公司于1988年从街机移植到红白机上的。</p>
<p>回到耦合的话题上来，因为早先的掌上游戏机将游戏本身内置在机器当中，游戏和机器这两个模块之间的关系过于紧密，所以游戏玩儿腻了，游戏机就没用了，游戏机出问题了，游戏也再也不能玩儿了。而红白机的游戏和游戏机之间的关系是相对独立的，只要它们都遵循制定好的协议，就可以独立的发展和变化。游戏卡带摔坏了，其他的游戏一样可以在机器上运行；自己的游戏机坏了，把卡带拿到朋友家的游戏机上也能玩儿。红白机发展到后期，连游戏机的手柄也是可插拔的，如果手柄坏了，也只需要更换手柄即可</p>
<h4 id="编程运用"><a href="#编程运用" class="headerlink" title="编程运用"></a>编程运用</h4><p>前面曾经提到，从不同的层次看，聚合和耦合的程度也会有所不同。Sidtown和Fredborough的例子当中，从城市的层次来看，第二种设计完全达到了高内聚和低耦合的目标，然而，如果从城市的不同区域来看，这样的设计内聚性还不够。如果我们一直追究下去，恐怕Better Mousetrap所有的员工都要住在生产线上了。一味的追求高内聚，必然会造成模块的功能过于单一，而模块的数量出现急剧膨胀。所以，我们在设计和实现程序时必须要斟酌模块间的聚合和耦合程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/03/11/编译器/编译器/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/11/编译器/编译器/" itemprop="url">
                  编译器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-11T23:38:06+08:00">
                2015-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.objccn.io/issue-6-2/" target="_blank" rel="external">编译器</a></p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h5><blockquote>
<p>机器语言是用<a href="http://baike.baidu.com/view/18536.htm" target="_blank" rel="external">二进制</a>代码表示的计算机能直接识别和执行的一种机器指令的集合</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/CPU" target="_blank" rel="external">CPU</a>可直接解读的数据</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">以下是一些示例：</span><br><span class="line">指令部份的示例</span><br><span class="line">0000 代表 加载（LOAD）</span><br><span class="line">0001 代表 存储（STORE）</span><br><span class="line">...</span><br><span class="line">暂存器部份的示例</span><br><span class="line">0000 代表暂存器 A</span><br><span class="line">0001 代表暂存器 B</span><br><span class="line">...</span><br><span class="line">存储器部份的示例</span><br><span class="line">000000000000 代表地址为 0 的存储器</span><br><span class="line">000000000001 代表地址为 1 的存储器</span><br><span class="line">000000010000 代表地址为 16 的存储器</span><br><span class="line">100000000000 代表地址为 2^11 的存储器</span><br><span class="line">集成示例</span><br><span class="line">0000,0000,000000010000 代表 LOAD A, 16</span><br><span class="line">0000,0001,000000000001 代表 LOAD B, 1</span><br><span class="line">0001,0001,000000010000 代表 STORE B, 16</span><br><span class="line">0001,0001,000000000001 代表 STORE B, 1[1]</span><br></pre></td></tr></table></figure>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译[ 是从<a href="http://baike.baidu.com/view/60376.htm" target="_blank" rel="external">源代码</a>（通常为<a href="http://baike.baidu.com/view/14900.htm" target="_blank" rel="external">高级语言</a>）到能直接被计算机器或<a href="http://baike.baidu.com/view/1132.htm" target="_blank" rel="external">虚拟机</a>执行的<a href="http://baike.baidu.com/view/1272000.htm" target="_blank" rel="external">目标代码</a>（通常为低级语言或<a href="http://baike.baidu.com/view/111847.htm" target="_blank" rel="external">机器语言</a>）的翻译过程</p>
<h4 id="编译器前后端"><a href="#编译器前后端" class="headerlink" title="编译器前后端"></a>编译器前后端</h4><p><em>前端</em>:  前端是语言相关的，输出为抽象语法树；</p>
<blockquote>
<p> clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：</p>
</blockquote>
<p><em>后端:</em>后端是机器相关的，输出为机器代码。有些优化是机器无关的，这一部分可能被单列出来称为中端。</p>
<blockquote>
<p>LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/03/01/计算机基础知识/GPU/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/01/计算机基础知识/GPU/" itemprop="url">
                  GPU
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-03-01T12:38:30+08:00">
                2015-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="文章来源-GPU是如何工作的？"><a href="#文章来源-GPU是如何工作的？" class="headerlink" title="文章来源: GPU是如何工作的？"></a>文章来源: <a href="http://mt.sohu.com/20160822/n465388684.shtml" target="_blank" rel="external">GPU是如何工作的？</a></h4><p><a href="http://www.360doc.com/content/13/0106/18/3267996_258608632.shtml" target="_blank" rel="external">GPU是如何工作的</a></p>
<p>渲染:使用GPU处理数据，输出可以显示的格式</p>
<p>光栅化:将矢量图形转换为像素点的过程 </p>
<p>即是将矢量图形转换为位图(由像素点组成的图形)</p>
<p><img src="https://pic4.zhimg.com/37b99f0d42dfc4b15468b873c1b6b487_b.jpg" alt=""></p>
<p>纹理: </p>
<p>GPU图形处理，可以大致分成 5 个步骤，如下图箭头的部分。分别为 vertex shader、primitive processing、rasterisation、fragment shader、testing and blending。</p>
<p><img src="http://img.mp.itc.cn/upload/20160822/c133024af8984192a98334c820b52050_th.jpeg" alt="img"></p>
<p>　　三维座标绘图并产生屏幕输出的图形</p>
<p><strong>第一步</strong>，vertex shader。是将三维空间中数个（x,y,z）顶点放进 GPU 中。在这一步骤中，电脑会在内部模拟出一个三维空间，并将这些顶点放置在这一空间内部。接着，投影在同一平面上，也是我们将看到的画面。同时，存下各点距离投影面的垂直距离，以便做后续的处理。</p>
<p>这个过程就像是本地球观看星星一般。地球的天空，就像是一个投影面，所有的星星，不管远近皆投影在同一面上。本地球的我们，抬起头来观看星星，分不出星星的远近，只能分辨出亮度。GPU 所投影出的结果，和这个情况类似。</p>
<p><img src="http://img.mp.itc.cn/upload/20160822/156b2c1a964e44c7a3318251da8a3771_th.jpeg" alt="img"></p>
<p>　　从地球所看到的星空，星星就像是投影到一球面上，除非使用特别的仪器，不然分不出星星和地球的距离</p>
<p><strong>第二步</strong>，primitive processing。是将相关的点链接在一起，以形成图形。在一开始输入数个顶点进入 GPU 时，程序会特别注记哪些点是需要组合在一起，以形成一线或面。就像是看星座的时候一样，将相关连的星星连起来，形成特定的图案。</p>
<p><strong>第三步</strong>，rasterisation。因为电脑的屏幕是由一个又一个的像素组成，因此，需要将一条连续的直线，使用绘图的演算法，以方格绘出该直线。图形也是以此方式，先标出边线，再用方格填满整个平面。</p>
<p><strong>第四步</strong>，fragment shader。将格点化后的图形着上颜色。所需着上的颜色也是于输入时便被注记。在游玩游戏时，这一步相当耗费 GPU 的计算资源，因为光影的效果、物体表面材质皆是在这一步进行，这些计算决定着游戏画面的精细程度。因此在游玩游戏时，调高游戏画面品质大幅增加这一步的计算负担，降低游戏品质。</p>
<p><img src="http://img.mp.itc.cn/upload/20160822/e12b16c48ec84e64a751b9cd855d6c8d.jpeg" alt="img"></p>
<p>　　将一个三角形，用方格呈现近似原始图案，并着上颜色。一块又一块的方格，就是显示器上的像素</p>
<p><strong>最后一步</strong>，testing and blending。便是将第一步所获得的投影垂直距离取出，和第四步的结果一同做最后处理。在去除被会被其他较近距离的物体挡住的物体后，让剩下的图形放进 GPU 的输出内存。之后，结果便会被送到电脑屏幕显示。</p>
<p><img src="http://image58.360doc.com/DownloadImg/2013/01/0618/29425927_1.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="tony2009" />
          <p class="site-author-name" itemprop="name">tony2009</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">73</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tony2009</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
