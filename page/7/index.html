<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="托尼的开发笔记">
<meta property="og:url" content="atony2099.github.io/page/7/index.html">
<meta property="og:site_name" content="托尼的开发笔记">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="托尼的开发笔记">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="atony2099.github.io/page/7/"/>





  <title> 托尼的开发笔记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">托尼的开发笔记</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/02/11/性能优化/UIView的绘制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/11/性能优化/UIView的绘制/" itemprop="url">
                  UIView的绘制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-11T10:28:35+08:00">
                2016-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="CPU流程"><a href="#CPU流程" class="headerlink" title="CPU流程"></a>CPU流程</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-21/11221206-file_1484987191790_9c88.png" alt=""></p>
<ol>
<li><p>每一个View都是一个Layer，每一个layer都有一个content，这个content指向一个缓存，叫做backingstore。</p>
<p>Layer管理位图状态信息</p>
<blockquote>
<p>A layer merely manages the state information surrounding a bitmap. </p>
</blockquote>
</li>
<li><p>当View绘制的时候，CPU执行drawRect，写入layer的backingstore</p>
<p>​</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UILabel* label = [[UILabel alloc]initWithFrame:CGRectMake(10, 50, 300, 14)];</span><br><span class="line">label.backgroundColor = [UIColor whiteColor];</span><br><span class="line">label.font = [UIFont systemFontOfSize:14.0f];</span><br><span class="line">label.text = @&quot;test&quot;;</span><br><span class="line">[self.view addSubview:label];</span><br></pre></td></tr></table></figure>
<ol>
<li><p>dirty views</p>
<blockquote>
<p>当一个view改变布局或者属性,或者主动调用setneedlaytout/setneeddisplay，这个view就会被标记为dirty views,</p>
</blockquote>
<p><img src="http://my.csdn.net/uploads/201207/19/1342691059_7152.jpg" alt=""></p>
<p>​</p>
</li>
</ol>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-21/54271723-file_1484987856789_1150d.png" alt=""></p>
<ol>
<li><p>在runloop周期开始的时候，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// coreanimaiton 注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件</span><br><span class="line">//当mainThread即将休眠的时候调用</span><br><span class="line">[CATransaction commit] </span><br><span class="line">// 将dirty view提交到全局的一个容器里面</span><br></pre></td></tr></table></figure>
</li>
<li><p>drawrect被调用，通过Core Graphic的的api绘制bitmap，写入layer的backingstore</p>
</li>
<li><p>清空dirty flag标记</p>
</li>
<li><p>当label的内容改变的时候，重新被标志位dirty。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">   QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">       CA::Transaction::commit();</span><br><span class="line">           CA::Context::commit_transaction();</span><br><span class="line">               CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                   CA::Layer::layout_if_needed();</span><br><span class="line">                         [CALayer layoutSublayers];</span><br><span class="line">                         [UIView layoutSubviews];</span><br><span class="line">                   CA::Layer::display_if_needed();</span><br><span class="line">                         [CALayer display];</span><br><span class="line">                         [UIView drawRect];</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 我们的要渲染的layer已经有了bitmap content的时候，这个content一般来说是一个CGImageRef，CoreAnimation会创建一个OpenGL的Texture并将CGImageRef（bitmap）和这个Texture绑定，通过TextureID来标识。</p>
<p> 这个对应关系建立起来之后，剩下的任务就是GPU如何将Texture渲染到屏幕上了。</p>
<p> <strong>简而言之，CoreAnimation会将bitmap先转换为gpu可处理的texture</strong></p>
</blockquote>
<h4 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h4><p><img src="http://vizlabxt.github.io/images/2013/11/QQ20131123-4.png" alt=""></p>
<blockquote>
<ol>
<li>CPU将准备好的bitmap放到RAM里，GPU去搬这快内存到VRAM中处理。</li>
<li>合成和渲染texture</li>
</ol>
</blockquote>
<h5 id="Compositing："><a href="#Compositing：" class="headerlink" title="Compositing："></a>Compositing：</h5><p>Compositing是指将多个纹理拼到一起的过程，</p>
<p>两个view叠加在一起，计算公式如下:</p>
<blockquote>
<p>R = S+D*(1-Sa)</p>
</blockquote>
<p>R = S+D*(1-Sa)`</p>
<p><code>R</code>: 为最终的像素值</p>
<p><code>S</code>: 代表 上面的Texture（Top Texture）</p>
<p><code>D</code>: 代表下面的Texture(lower Texture)</p>
<p>其中S,D都已经pre-multiplied各自的alpha值。</p>
<p><code>Sa</code>代表Texture的alpha值。</p>
<blockquote>
<p>view层级越复杂，alpha = 1越多，计算越复杂。</p>
</blockquote>
<h4 id="UIView-和CAlayer区别"><a href="#UIView-和CAlayer区别" class="headerlink" title="UIView 和CAlayer区别"></a>UIView 和CAlayer区别</h4><ul>
<li>封装: UIView是在Calayer 基础上进一步封装，每个UIView都有一个RootLayer，</li>
</ul>
<ol>
<li>UIView一些基础几何属性来自于layer</li>
</ol>
<ol>
<li><p>UIView继承了Responder，响应事件</p>
<p>​</p>
</li>
</ol>
<ul>
<li>绘制 和 显示: UIView底层调用coreGraphics绘制视图信息，这些绘图信息会被转换为bitMap数据缓存到Calyer的backingStore，</li>
</ul>
<ul>
<li>缓存在自己的contents中，进一步通过CoreAnimaiton 将这些位图信息提交到GPU进行渲染和合成。</li>
</ul>
<p><a href="http://joeshang.github.io/2015/01/10/understand-contentsscale/" target="_blank" rel="external">理解contentsScale</a></p>
<p><a href="http://vizlabxt.github.io/blog/2012/10/22/UIView-Rendering/" target="_blank" rel="external">理解UIView的绘制</a></p>
<p><a href="http://www.jianshu.com/p/079e5cf0f014" target="_blank" rel="external">详解CALayer 和 UIView的区别和联系</a></p>
<p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/" target="_blank" rel="external">OPENGL</a></p>
<p><a href="http://apprize.info/apple/ios/6.html" target="_blank" rel="external">iOS Programming: The Big Nerd Ranch Guide (2014)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/02/08/atomic/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/08/atomic/" itemprop="url">
                  nonatomic VS atomic
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-08T01:26:58+08:00">
                2016-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>stackoverflow上关于这个问题的讨论:<a href="http://stackoverflow.com/questions/588866/whats-the-difference-between-the-atomic-and-nonatomic-attributes" target="_blank" rel="external">What’s the difference between the atomic and nonatomic attributes?</a></p>
<p>主要在于他们生成的getter 和setter方法有所不同。</p>
<p>对于atomic关键字，相关伪代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (UITextField *) userName &#123;</span><br><span class="line">    </span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">       return _userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setUserName:(UITextField *)userName &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">      _userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 也就是通过加锁来保证线程安全，能避免线程分配竞争，保证数据操作的完整性</p>
<p>更具体例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic)CGRect domain;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-1.png" alt=""></p>
<p>假如你需要在两条线程上修改domin，如下</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;b&gt;thread 1:&lt;/b&gt; puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);</span><br><span class="line">&gt; &lt;b&gt;thread 2:&lt;/b&gt; puppy.domain = CGRectMake (10.0, 20.0, 30.0, 40.0);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>你只会得到两种结果:</p>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-3.png" alt=""></p>
<p>或者：</p>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-4.png" alt=""></p>
<p>而不会出现:</p>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-2.png" alt=""></p>
<p>这种混合的状态。</p>
<p>所以我们可以说atomic是一种线程安全的机制，但要注意这种线程安全是局部的，之所以这样说，我们还是来看一个例子更直观：</p>
<p>假如puppy有三个成员变量，那我们在A线程设置它的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puppy.name = @&quot;Hoover&quot;;</span><br><span class="line">puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);</span><br><span class="line">puppy.housebroken = NO;</span><br></pre></td></tr></table></figure>
<p>在b线程设置它的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puppy.name = @&quot;Rumpelstiltskin&quot;;</span><br><span class="line">puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);</span><br><span class="line">puppy.housebroken = YES;</span><br></pre></td></tr></table></figure>
<p>我们有可能得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puppy.name = @&quot;Hoover&quot;;</span><br><span class="line">puppy.domain = CGRectMake (10.0, 20.0, 30.0, 40.0);</span><br><span class="line">puppy.housebroken = NO;</span><br></pre></td></tr></table></figure>
<p>这样一组结果，这组数据是错误的。所以单纯靠atomic并不能保证真正的线程安全。</p>
<p>参考:<a href="https://www.bignerdranch.com/blog/property-values/" target="_blank" rel="external">Property Values</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/02/08/字符串，日期的处理/NSString/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/08/字符串，日期的处理/NSString/" itemprop="url">
                  nonatomic VS atomic
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-08T01:26:58+08:00">
                2016-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>NSString 大法好</p>
</blockquote>
<p>1.<a href="http://stackoverflow.com/questions/2753956/how-do-i-check-if-a-string-contains-another-string-in-objective-c" target="_blank" rel="external">How do I check if a string contains another string in Objective-C</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *string = @&quot;hello bla blah&quot;;</span><br><span class="line">if ([string containsString:@&quot;bla&quot;]) &#123;</span><br><span class="line">  NSLog(@&quot;string contains bla!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  NSLog(@&quot;string does not contain bla&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/02/08/面试准备/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/08/面试准备/" itemprop="url">
                  nonatomic VS atomic
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-08T01:26:58+08:00">
                2016-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试准备</p>
<ul>
<li>图解http  三个🍅 &lt;= 4个🍅</li>
<li>swift复习 </li>
<li>图文混排</li>
<li>MVVM + RAC</li>
<li>​</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/02/08/网络请求/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/08/网络请求/" itemprop="url">
                  nonatomic VS atomic
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-08T01:26:58+08:00">
                2016-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>Apps that communicate with a server via HTTP usually have two particular requirements:</p>
<blockquote>
<p>don’t make the user wait for data whenever possible, </p>
<p> be useful when there is no internet connection</p>
</blockquote>
<p>iOS  has the APIs we need to implement response caching and offline mode.</p>
<p>Very little code is required, even less if your server plays nice with cache headers and you’re targeting iOS 7 and above.</p>
<p>The shared <code>NSURLCache</code> gives us much out of the box</p>
<h4 id="offlineMode"><a href="#offlineMode" class="headerlink" title="offlineMode"></a>offlineMode</h4><p>In most cases, showing old data is better that showing no data (exceptions being weather and stock, for example). </p>
<p>If we want our offline mode to always return the cached data, then our requests must have a different cache policy, one that uses cache data regardless of its expiration date. Both <code>NSURLRequestReturnCacheDataDontLoad</code> and <code>NSURLRequestReturnCacheDataElseLoad</code> fit this criteria. In particular, <code>NSURLRequestReturnCacheDataElseLoad</code>has the advantage of trying the network if no cached response is found</p>
<ol>
<li>what is cache-Control </li>
</ol>
<h4 id="Http-Request"><a href="#Http-Request" class="headerlink" title="Http  Request"></a>Http  Request</h4><ol>
<li><p>http  request</p>
<ul>
<li>请求行</li>
<li>请求头: </li>
<li>请求体</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; POST /index.php HTTP/1.1</span><br><span class="line">&gt; Host: localhost</span><br><span class="line">&gt; User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2</span><br><span class="line">&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">&gt; Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">&gt; Accept-Encoding: gzip, deflate</span><br><span class="line">&gt; Connection: keep-alive</span><br><span class="line">&gt; Referer: http://localhost/</span><br><span class="line">&gt; Content-Length：25</span><br><span class="line">&gt; Content-Type：application/x-www-form-urlencoded</span><br><span class="line">&gt;</span><br><span class="line">&gt; username=aa&amp;password=1234</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>http response</p>
<ul>
<li>响应行</li>
<li>响应头</li>
<li>响应体</li>
</ul>
</li>
</ol>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; HTTP/1.1 200 OK</span><br><span class="line">&gt; Date: Sun, 17 Mar 2013 08:12:54 GMT</span><br><span class="line">&gt; Server: Apache/2.2.8 (Win32) PHP/5.2.5</span><br><span class="line">&gt; X-Powered-By: PHP/5.2.5</span><br><span class="line">&gt; Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</span><br><span class="line">&gt; Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">&gt; Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class="line">&gt; Pragma: no-cache</span><br><span class="line">&gt; Content-Length: 4393</span><br><span class="line">&gt; Keep-Alive: timeout=5, max=100</span><br><span class="line">&gt; Connection: Keep-Alive</span><br><span class="line">&gt; Content-Type: text/html; charset=utf-8</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br><span class="line">&gt; &lt;html&gt;</span><br><span class="line">&gt; &lt;head&gt;</span><br><span class="line">&gt; &lt;title&gt;HTTP响应示例&lt;title&gt;</span><br><span class="line">&gt; &lt;/head&gt;</span><br><span class="line">&gt; &lt;body&gt;</span><br><span class="line">&gt; Hello HTTP!</span><br><span class="line">&gt; &lt;/body&gt;</span><br><span class="line">&gt; &lt;/html&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>http 的缓存策略  Cache-Control</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: <span class="keyword">private</span>/<span class="keyword">public</span> Public 响应会被缓存，并且在多用户间共享。 Private 响应只能够作为私有的缓存，不能再用户间共享。</span><br><span class="line">Cache-Control: no-cache：不进行缓存 </span><br><span class="line">Cache-Control: max-age=x：缓存时间 以秒为单位 </span><br><span class="line">Cache-Control: must-revalidate：如果页面是过期的 则去服务器进行获取。</span><br></pre></td></tr></table></figure>
<p>http1.0 vs http 1.0  response header</p>
<p>Pragma : no-cache 表示防止客户端缓存，需要强制从服务器获取最新的数据；<br>Expires: HTTP1.0 响应头，本地副本缓存过期时间，如果客服端发现缓存文件没有过期则不发送请求，HTTP的日期必须是格林威治时间（GMT）,如”Expires:Wed,14 Mar 2015 14:30:32 GMT” </p>
<p>Cache-Control </p>
<h4 id="how-cache-control-work"><a href="#how-cache-control-work" class="headerlink" title="how cache-control work"></a>how cache-control work</h4><p>An <a href="http://nshipster.com/nsurlcache/" target="_blank" rel="external"><code>NSURLCache</code></a> <code>sharedCache</code> is enabled by default and will be used by any <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/NSURLConnection_Class/Reference/Reference.html" target="_blank" rel="external"><code>NSURLConnection</code></a>objects fetching URL contents for you.</p>
<p>Unfortunately, it has a tendency to hog memory and does not write to disk in its default configuration. To tame the beast and potentially add some persistance, you can simply declare a shared <a href="http://nshipster.com/nsurlcache/" target="_blank" rel="external"><code>NSURLCache</code></a> in your app delegate like so:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:2 * 1024 * 1024</span><br><span class="line">                                              diskCapacity:100 * 1024 * 1024</span><br><span class="line">                                              diskPath:nil];</span><br><span class="line">[NSURLCache setSharedURLCache:sharedCache];</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.originate.com/blog/2014/02/20/afimagecache-vs-nsurlcache/" target="_blank" rel="external">How Does Caching Work in AFNetworking? : AFImageCache &amp; NSUrlCache Explained</a></p>
<p><a href="http://www.hpique.com/2014/03/how-to-cache-server-responses-in-ios-apps/" target="_blank" rel="external">How to cache server responses in iOS apps</a></p>
<p><a href="https://cnbin.github.io/blog/2016/02/20/http-qing-qiu-,-xiang-ying-,-huan-cun/" target="_blank" rel="external">HTTP-请求、响应、缓存</a></p>
<p><a href="http://tools.jb51.net/table/http_request_method" target="_blank" rel="external">HTTP请求方法对照表</a><br><a href="http://www.cocoachina.com/ios/20160525/16438.html" target="_blank" rel="external">HTTP in iOS你看我就够</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/01/07/copy/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/07/copy/" itemprop="url">
                  copy探究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-07T00:24:48+08:00">
                2016-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-浅拷贝-amp-amp-深拷贝"><a href="#1-浅拷贝-amp-amp-深拷贝" class="headerlink" title="1. 浅拷贝&amp;&amp;深拷贝"></a>1. 浅拷贝&amp;&amp;深拷贝</h4><p><img src="http://upload-images.jianshu.io/upload_images/1111290-d90c09e5df129a5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1111290-bc1700453091b35d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>
<p>如图所示,浅拷贝只是对指针的复制，而深拷贝不仅复制了指针，而且复制了指针所指向的对象</p>
<h4 id="2-非集合对象和集合对象的复制"><a href="#2-非集合对象和集合对象的复制" class="headerlink" title="2.非集合对象和集合对象的复制"></a>2.非集合对象和集合对象的复制</h4><p>​    例1：对NSString进行<code>copy</code> 和<code>mutableCopy</code>操作</p>
<p><img src="http://i4.piimg.com/567571/6ba311780cc68886.png" alt=""></p>
<p><img src="http://i2.piimg.com/567571/5ef7ea3ff110a20d.png" alt=""></p>
<p>​    例2：对NSMutableString进行<code>copy</code> 和<code>mutableCopy</code>操作</p>
<p><img src="http://i2.piimg.com/567571/8a51f2e1269869c1.png" alt=""></p>
<p><img src="http://i2.piimg.com/567571/272b2ee7212b4f41.png" alt=""></p>
<p><strong>综合以上两个例子,我们可以得出如下结论</strong></p>
<blockquote>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
<p>warnings: 对集合对象(NSArray,NSDictonary…)上面的结论也同样使用，但是对于集合对象里面的元素对象，始终是浅复制，也即只是复制指针。</p>
</blockquote>
<h4 id="Copy关键字的使用"><a href="#Copy关键字的使用" class="headerlink" title="Copy关键字的使用"></a>Copy关键字的使用</h4><p>通常我们声明NSString，NSArray，NSDictonary类型的变量的时候，都是使用copy关键字，这是为什么呢？</p>
<p>stackoverflow有个类似的问题<a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain" target="_blank" rel="external">NSString property: copy or retain?</a></p>
<blockquote>
<p> For attributes whose type is an immutable value class that conforms to the <code>NSCopying</code> protocol, you almost always should specify <code>copy</code> in your <code>@property</code> declaration. Specifying <code>retain</code>(strong) is something you almost never want in such a situation.</p>
</blockquote>
<p>从根本上说，由于object-c是一门多态的语言，我们声明变量为NSString，NSArray，NSDictonary类型的时候，本意是想变量为不可变类型，但由于父类的指针可以指向子类对象，所有就有可能发生未知的错误，如下: </p>
<p><img src="http://i2.piimg.com/567571/348394d76131ec1c.png" alt=""></p>
<p>上面输出的结果是<code>hi world</code>,而不是我们一开始指定的<code>hello wrold</code>，而如果我们指定关键字为<code>copy</code>, 就能保证name指针指向的是immutableObject，防止数据被篡改而一起不必要的麻烦。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/12/内存管理/autoreleasepool/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/12/内存管理/autoreleasepool/" itemprop="url">
                  autorelesePool
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-12T20:18:02+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="autoreleasePool的实现原理"><a href="#autoreleasePool的实现原理" class="headerlink" title="autoreleasePool的实现原理"></a>autoreleasePool的实现原理</h4><ol>
<li>autoreleasePool是由若干个AutoreleasePoolPage以双向链表组成， 每一个线程的 autoreleasepool 按堆栈的方式存储对象的指针，id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置<ul>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
<li>每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个`哨兵对象，值为0（也就是个nil）,并从哨兵对象对象对象位置开始存储指针</li>
</ul>
</li>
</ol>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/66532911-file_1484604072733_11269.jpg" alt=""></p>
<ol>
<li>objc_autoreleasePoolPush的返回值正是这个哨兵对象的地址，被objc_autoreleasePoolPop(哨兵对象)作为入参，于是：<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置<br><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/52002764-file_1484604072858_134b7.jpg" alt=""></li>
</ul>
</li>
</ol>
<h4 id="autoreleased-对象的释放时机"><a href="#autoreleased-对象的释放时机" class="headerlink" title="autoreleased 对象的释放时机"></a>autoreleased 对象的释放时机</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/32208599-file_1484656781760_283c.gif" alt=""></p>
<p> 在每一个runloop周期内，runloop 都会创建一个autoreleasepool，在runloop即将休眠 drain 这个pool</p>
<p>autoreleased对象此时被释放</p>
<h4 id="autoreleasepool-使用场景"><a href="#autoreleasepool-使用场景" class="headerlink" title="autoreleasepool 使用场景"></a>autoreleasepool 使用场景</h4><ol>
<li><p>If you write a loop that creates many temporary objects.</p>
<p>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application</p>
<blockquote>
<p>个人理解: 如果在短时间创建了大量autoreleased对象，内存会迅速增加，但是autoreleased对象要等待本次runloop周期结束后才释放，这时候可以手动创建autoreleasepool池即时释放</p>
</blockquote>
<p>​</p>
</li>
<li><p>If you spawn a secondary thread.</p>
<p>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.</p>
<blockquote>
<p>个人理解: 在实际开发中，我们最长使用时GCD和NSOperation,在两个框架下，会自动帮我们构建autoreleasepool，所以即使没有显示调用autoreleasepool，也不一定会造成很大的内存泄露问题,</p>
<p>但是创建大量对象的时候还是故意自己主动创建autoreleasepool</p>
</blockquote>
<p>参考stack overflow：</p>
<p><a href="http://stackoverflow.com/questions/4141123/do-you-need-to-create-an-nsautoreleasepool-within-a-block-in-gcd" target="_blank" rel="external">Do you need to create an NSAutoreleasePool within a block in GCD?</a></p>
<blockquote>
<p>If your block creates more than a few Objective-C objects, you might want to enclose parts of your block’s code in an @autorelease block to handle the memory management for those objects. Although GCD dispatch queues have their own autorelease pools, they make no guarantees as to when those pools are drained. If your application is memory constrained, creating your own autorelease pool allows you to free up the memory for autoreleased objects at more regular intervals.</p>
</blockquote>
<p>​</p>
</li>
</ol>
<p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="external">Using Autorelease Pool Blocks</a></p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/12/load&&initialize/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/12/load&&initialize/" itemprop="url">
                  load && initialize
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-12T16:32:39+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="load-amp-amp-initialize"><a href="#load-amp-amp-initialize" class="headerlink" title="load &amp;&amp; initialize"></a>load &amp;&amp; initialize</h4><ul>
<li>load</li>
</ul>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
</blockquote>
<p>从上面的描述可以看出这个方法调用的时机很早，在类(分类)被加载到runtime的时候就会调用，同时只有类实现了这个方法才能被响应。</p>
<ul>
<li>initialize</li>
</ul>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. </p>
</blockquote>
<p>不同于load，initialize只有在类或者它的子类第一次接收到消息之前才会调用,相当于懒加载。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    [super initialize];</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__func__,[self class]);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Dog : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    [super initialize];</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在main.m文件里执行上述代码，可以输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Animal load]</span><br><span class="line">+[Dog load] </span><br><span class="line">main</span><br></pre></td></tr></table></figure>
<p>可以看出在没有主动对类执行操作情况下，load会默认执行，并且在main函数之前执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__func__,[self class]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    Dog *dog = [[Dog alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行结果: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Animal load]</span><br><span class="line">+[Animal initialize] Animal</span><br><span class="line">+[Animal initialize] Dog</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出initialize明显的一个特点是当子类没有实现的时候，它会主动调用父类的方法，而load并没有这一特性，为了解释这一特性，我们得从runtime源码层面剖析: </p>
<p>load方法的调用核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Call all +loads for the detached list.</span><br><span class="line">for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">    Class cls = classes[i].cls;</span><br><span class="line">    load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">    if (!cls) continue;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    (*load_method)(cls, SEL_load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码循环调用所有类的 +load 方法。<strong>注意</strong>，这里是（调用分类的 +load 方法也是如此）直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 对 +load 方法进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。</p>
<p>这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Class supercls;</span><br><span class="line">    BOOL reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    monitor_enter(&amp;classInitLock);</span><br><span class="line">    if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">        cls-&gt;setInitializing();</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    monitor_exit(&amp;classInitLock);</span><br><span class="line"></span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line"></span><br><span class="line">        // Record that we&apos;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&apos;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有两个关键点: </p>
<ul>
<li>入参的父类进行了递归调用，以确保父类优先于子类初始化</li>
<li>runtime 使用了发送消息 <code>objc_msgSend</code>的方式对 +initialize 方法进行调用。也就是说 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>load</p>
<blockquote>
<p>method swizzling</p>
</blockquote>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>两者在runtime都是递归调用，父类先于子类被调用</li>
<li>load根据函数地址发送，(分类.子类，父类调用分开)  initialise(懒加载) meg_send发送 (子类没有实现会查找父亲的方法列表，分类覆盖所属类的实现)</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时</td>
<td>收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>若自身未定义，是否沿用父类的方法？</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
<p>参考: </p>
<p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">Objective-C +load vs +initialize</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/11/内存管理/内存管理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/11/内存管理/内存管理/" itemprop="url">
                  内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-11T23:38:06+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>version 1.0  <object-c高级标编程> 19页 68页 关于hashMap 还不是很懂</object-c高级标编程></p>
</blockquote>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>参考: <a href="http://www.cnblogs.com/jsean/articles/1599799.html" target="_blank" rel="external">HEAP和STACK的区别</a></p>
<p><a href="http://c.biancheng.net/cpp/biancheng/view/141.html" target="_blank" rel="external">C++变量的存储类别（动态存储、静态存储、自动变量、寄存器变量、外部变量）</a></p>
<p><strong>自动变量</strong>（<em>Automatic Variable</em>）指的是局部<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="external">作用域</a><a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">变量</a>)， 具体来说即是在<a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E6%B5%81" target="_blank" rel="external">控制流</a>进入变量作用域时系统自动为其<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" target="_blank" rel="external">分配存储空间</a>，并在离开作用域时释放空间的一类变量。在许多<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="external">程序语言</a>中，自动变量与术语“<a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="external">局部变量</a>”（<em>Local Variable</em>）所指的变量实际上是同一种变量。</p>
<h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>栈区： 系统自动分配并释放的， 存放局部变量和形参 ，用栈的方式操作(fifo)，连续</p>
<p>堆区：由程序员手动创建并释放，存放对象 ， 用链表方式记录空闲地址，不连续</p>
<p>全局区(静态区)：全局变量和静态变量</p>
<p>常量区: 存放常量字符串，程序结束后由系统释放</p>
<p>代码区：存放二进制代码</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;_=5707006" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main.cpp </span><br><span class="line">　　<span class="keyword">int</span> a = <span class="number">0</span>; 全局初始化区 </span><br><span class="line">　　<span class="keyword">char</span> *p1; 全局未初始化区 </span><br><span class="line">　　main() </span><br><span class="line">　　&#123; </span><br><span class="line">　　<span class="keyword">int</span> b; 栈 </span><br><span class="line">　　<span class="keyword">char</span> s[] = <span class="string">"abc"</span>; 栈 </span><br><span class="line">　　<span class="keyword">char</span> *p2; 栈 </span><br><span class="line">　　<span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="number">123456</span>\<span class="number">0</span>在常量区，p3在栈上。 </span><br><span class="line">　　<span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； 全局（静态）初始化区 </span><br><span class="line">　　p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);  堆</span><br><span class="line">　　p2 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);  堆</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>栈的存储</strong>：</p>
<p>在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>　　当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 </p>
</blockquote>
<h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC:"></a>MRC:</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>苹果为了简化内存管理，设计一套简单的内存管理规则。在这个规则下 <strong>内存对象由系统去处理释放的问题</strong></p>
<p>创建者和持有者处理好自己的问题</p>
<ul>
<li><p>谁创建，谁释放 (alloc , new ,copy，mutable copy ，<strong>或者以这些关键字开头的自定义初始化方法</strong>)</p>
<blockquote>
<p><strong>如果创建一个方法，在方法里返回一个对象，非以上关键字命名的，那这个方法应该怎么写呢?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (id)object&#123;</span><br><span class="line">&gt;     id obj = [[NSObject alloc]  init];</span><br><span class="line">&gt;     [obj autorelease]; // 在一个runloop周期后被释放</span><br><span class="line">&gt;</span><br><span class="line">&gt;     return object</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>谁持有，谁释放(retain)</p>
</li>
</ul>
<h5 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h5><p>引用计数表(哈希表)</p>
<p>记录对象的内存地址和引用数量。当对象的引用计数器数量是0的时候，对象被销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (retainCount== <span class="number">0</span>) &#123;</span><br><span class="line">  	[self delloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><p>weak的实现</p>
<p>weak 和assign 都表示非拥有，weak会在 对象释放的时候，指向nil，安全</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	id __weak obj1 = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">&#123;</span><br><span class="line">  id obj1</span><br><span class="line">  obj1 = <span class="number">0</span>;</span><br><span class="line">  objc_storeweak(&amp;obj1,obj)</span><br><span class="line">  objc_storeweak(&amp;obj1,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">思路： </span><br><span class="line"><span class="number">1.</span> objc_storeweak以对象的内存地址为key，以weak变量的地址为value，注册到weak表中</span><br><span class="line"><span class="number">2</span>， 如果第二个参数为<span class="number">0</span>(当对象没有强引用的时候)，则同样以对象的内存地址为key，通过weak表找到weak变量 ，将他们赋值为nil，从weak表中删除</span><br></pre></td></tr></table></figure>
<p>启示：weak操作会消耗cpu资源，建议只在循环引用时候使用</p>
<h4 id="autoreleasePool"><a href="#autoreleasePool" class="headerlink" title="autoreleasePool"></a>autoreleasePool</h4><h5 id="autoreleasePool的实现原理"><a href="#autoreleasePool的实现原理" class="headerlink" title="autoreleasePool的实现原理"></a>autoreleasePool的实现原理</h5><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/11810272-file_1484604058069_224e.jpg" alt=""></p>
<ol>
<li><p>autoreleasePool是由若干个AutoreleasePoolPage以双向链表组成， </p>
<p><strong>每一个线程的 autoreleasepool 按堆栈的方式存储对象的指针</strong></p>
<ul>
<li><code>id *next</code>指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>
</li>
<li><p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的AutoreleasePoolPage中<strong>add进一个`哨兵对象</strong>，值为0（也就是个nil）</p>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/66532911-file_1484604072733_11269.jpg" alt=""></p>
</li>
<li><p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop(哨兵对象)</code>作为入参，于是：</p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次<code>- release</code>消息，并向回移动<code>next</code>指针到正确位置</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg" alt=""></p>
</li>
</ol>
<h5 id="autoreleasePool的释放时机"><a href="#autoreleasePool的释放时机" class="headerlink" title="autoreleasePool的释放时机"></a>autoreleasePool的释放时机</h5><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-17/32208599-file_1484656781760_283c.gif" alt=""></p>
<p>在没一个runloop周期内，runloop 都会创建一个autoreleasepool</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/11/性能优化/性能优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/11/性能优化/性能优化/" itemprop="url">
                  性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-11T13:18:36+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="显示原理"><a href="#显示原理" class="headerlink" title="显示原理"></a>显示原理</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-20/95673407-file_1484905412627_29bc.png" alt=""></p>
<ol>
<li>CPU 计算好显示内容，如视图的创建、布局计算、图片解码、文本绘制等。随后CPU将计算好的内容提交到GPU</li>
<li>GPU进行变换,合成，渲染， 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</li>
</ol>
<h4 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因:"></a>卡顿产生的原因:</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-21/41214618-file_1484935773331_2c20.jpg" alt=""></p>
<ol>
<li>当显示器的电子扫描枪回到原位，准备下一帧扫描的时候，会付出一个Vsync，</li>
<li>当vsync开始下一帧扫描的时候，GPU没有把完成渲染放到帧缓冲区，那一帧就会被废弃，这就是所谓的掉帧</li>
</ol>
<blockquote>
<p>总结:显示器秒回产生60个垂直同步信号，如果在信号间隔cpu 和 gpu 没有把要显示的内容准备好，那一帧就会被废弃掉，产生掉帧，这也是卡顿的原因</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<p>保持CPU和GPU负载均衡</p>
</blockquote>
<h5 id="减少CPU的负载"><a href="#减少CPU的负载" class="headerlink" title="减少CPU的负载:"></a>减少CPU的负载:</h5><p><strong>方法</strong>:空间换时间</p>
<ul>
<li><p>对象的创建: 提前创建好 </p>
</li>
<li><p>布局(文本)的计算，做缓存</p>
</li>
<li><p>图像的解码: </p>
<blockquote>
<p>Once an image file has been loaded, it must then be decompressed. This decompression can be a computationally complex task and take considerable time. The decompressed image will also use substantially more memory thane the original</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路:开启子线程解码，参考sdwebimage的 的 decodedImageWithImage方法</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h5 id="减少GPU的负载"><a href="#减少GPU的负载" class="headerlink" title="减少GPU的负载:"></a>减少GPU的负载:</h5><ol>
<li><p>减少视图的混合，减少透明视图的混合</p>
</li>
<li><p>减少离屏渲染</p>
<p>​</p>
</li>
</ol>
<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>
<p><a href="https://gold.xitu.io/post/58667d86128fe10057eae0d2" target="_blank" rel="external">iOS 页面性能优化</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="tony2009" />
          <p class="site-author-name" itemprop="name">tony2009</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tony2009</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
