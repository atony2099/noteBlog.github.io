<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="托尼的开发笔记">
<meta property="og:url" content="atony2099.github.io/page/6/index.html">
<meta property="og:site_name" content="托尼的开发笔记">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="托尼的开发笔记">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="atony2099.github.io/page/6/"/>





  <title> 托尼的开发笔记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">托尼的开发笔记</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/01/20/其他-实际开发问题/NSCache/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/20/其他-实际开发问题/NSCache/" itemprop="url">
                  NSCache
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-20T13:28:35+08:00">
                2016-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>NSCache是什么？</p>
<blockquote>
<p>An NSCache object is a mutable  collection that stores key-value pairs, similar to an NSDictionary object. The NSCache class provides a programmatic interface to adding and removing objects and setting eviction policies based on the total cost and number of objects in the cache.</p>
<p>The NSCache class incorporates various auto-eviction policies, which ensure that a cache doesn’t use too much of the system’s memory. If memory is needed by other applications, these policies remove some items from the cache, minimizing its memory footprin</p>
<p>You can add, remove, and query items in the cache from different threads without having to lock the cache yourself.</p>
<p>Unlike an NSMutableDictionary object, a cache does not copy the key objects that are put into it.</p>
</blockquote>
<p>使用场景: 只有那种“重新计算起来很费事”的数据，才值得放入缓存，比如从网络或者从磁盘读取。</p>
<p>本地相关demo:  CellSizeCacheDemo</p>
<p>参考: <a href="http://www.15yan.com/story/45toOUzFGlr/" target="_blank" rel="external">Objective-C中的缓存</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2016/01/08/1runtime/runtime/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/08/1runtime/runtime/" itemprop="url">
                  Understanding the Objective-C Runtime
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-08T19:30:25+08:00">
                2016-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="runtime基础概念"><a href="#runtime基础概念" class="headerlink" title="runtime基础概念"></a>runtime基础概念</h4><h5 id="动态语言VS静态语言"><a href="#动态语言VS静态语言" class="headerlink" title="动态语言VS静态语言"></a>动态语言VS静态语言</h5><ul>
<li><p>c语言: 代码执行的逻辑在在编译的时候会决定好，编译完成之后直接顺序执行，无任何二义性</p>
</li>
<li><p>oc:它会尽可能地把代执行的决策从编译和链接的时候，推迟到运行时。(关于编译和连接，参考这篇文章<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="external">编译器的工作过程</a></p>
<blockquote>
<p>Objective-C最大的特色是承自<a href="https://zh.wikipedia.org/wiki/Smalltalk" target="_blank" rel="external">Smalltalk</a>的消息传递模型（message passing），此机制与今日<a href="https://zh.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="external">C++</a>式之主流风格差异甚大。Objective-C里，与其说对象互相<strong>调用方法</strong>，不如说对象之间<strong>互相传递消息</strong>更为精确。</p>
<p>定义：runtime是用c和汇编写的一个动态库，oc面向对象的能力是建立在这个库上的，他主要做了两件事</p>
<ul>
<li>封装: 封装(对象，类封装成结构体</li>
<li>消息派发</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="对象结构体"><a href="#对象结构体" class="headerlink" title="对象结构体"></a>对象结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;  <span class="comment">//对象内部的指针指向类对象结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;  <span class="comment">// 类对象结构体 </span></span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY; <span class="comment">// 类对象isa指针指向它的meta class</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line"></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  <span class="comment">// 父类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *methodLists   OBJC2_UNAVAILABLE;  <span class="comment">// 方法定义的链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;  <span class="comment">// 方法缓存的链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  <span class="comment">// 协议链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-13/70107463-file_1484309681712_8217.jpg" alt=""></p>
<p>类对象结构体存储着实例实例对象的方法列表，成员变量信息</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><h5 id="编译器转换"><a href="#编译器转换" class="headerlink" title="编译器转换"></a>编译器转换</h5><p>[receiver message];</p>
<p>会被编译器转换为</p>
<p>objc_msgSend(receiver, @selector(message));</p>
<blockquote>
<p> id objc_msgSend(id self, SEL _cmd, …)</p>
<ul>
<li><p>SEL表示选择器，是一个结构体，可以理解为一个字符串，它维护着一张SEL,将相同字符串的方法名映射到唯一一个SEL。</p>
<p>简单说SEL就是一个方法的id</p>
<p>typedef id (*IMP)(id, SEL, …);</p>
</li>
<li><p>IMP表示方法地址</p>
</li>
</ul>
</blockquote>
<p>objc_class中 method list保存了一组SEL&lt;-&gt;IMP的映射。</p>
<p><img src="http://img.blog.csdn.net/20130718230259187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWl5YWFpeHVleGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h5 id="obj-msgSend-执行"><a href="#obj-msgSend-执行" class="headerlink" title="obj_msgSend 执行"></a>obj_msgSend 执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...) &#123;</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">	IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);</span><br><span class="line">	imp(self, op, ...); //调用这个函数，伪代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找IMP</span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</span><br><span class="line"></span><br><span class="line">    if (!cls || !sel) return nil;</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel);</span><br><span class="line">   if (!imp) return _objc_msgForward; //这个是用于消息转发的</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel) &#123;</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;initialize()) &#123;</span><br><span class="line">        _class_initialize(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Class curClass = cls;</span><br><span class="line"></span><br><span class="line">    IMP imp = nil;</span><br><span class="line"></span><br><span class="line">    do &#123; //先查缓存,缓存没有时重建,仍旧没有则向父类查询</span><br><span class="line"></span><br><span class="line">        if (!curClass) break;</span><br><span class="line"></span><br><span class="line">        if (!curClass-&gt;cache) fill_cache(cls, curClass);</span><br><span class="line"></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line"></span><br><span class="line">        if (imp) break;</span><br><span class="line"></span><br><span class="line">    &#125; while (curClass = curClass-&gt;superclass);</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以梳理出相关方法的执行过程: </p>
<ol>
<li><p>检查receiver是否为nil，如果为nil，直接return(这也是为什么我们向一个nil发送消息不会crash)</p>
</li>
<li><p>根据receiver 内部的iSA指针找到它所指向的类对象，然后再根据SEL查询IMP </p>
<ul>
<li>先查询cache 方法链表</li>
<li>再从methodList查找</li>
<li>还没找到，就沿着继承体系向上查找，一直找到NSObject</li>
<li>如果一直查找到根类仍旧没有实现。调用_objc_msgForward函数，_objc_msgForward作用是在程序抛出<em>unrecognized selector sent to</em> 之前调用消息转发的方法，让你有机会拯救程序</li>
</ul>
<p>​</p>
<p>增加 方法的实现或者转发给其他对象</p>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-14/68070652-file_1484404278995_151e3.png" alt=""></p>
<p>​</p>
<ul>
<li><code>+resolveInstanceMethod:</code> 或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/203794-964ecb6df5e56591.png?imageView2/2/w/1240/q/100" alt=""></p>
<ul>
<li>fast forwarding: 调用这个方法，给你把这个消息转发给其他对象的机会,如果获取到，直接转发给它。如果返回nil，继续下面操作</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/203794-481320569772a444.png?imageView2/2/w/1240/q/100" alt=""></p>
<ul>
<li>Normal forwarding :这一步是 Runtime 最后一次给你挽救的机会。运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息 有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation 方法中选择将消息转发给其它对象。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/203794-7e5f61f4588a208e.png?imageView2/2/w/1240/q/100" alt=""></p>
<p>​</p>
</li>
</ol>
<h4 id="method-swizzle"><a href="#method-swizzle" class="headerlink" title="method swizzle"></a>method swizzle</h4><h5 id="是什么-改变method-list-SEL-所指向的IMP指针"><a href="#是什么-改变method-list-SEL-所指向的IMP指针" class="headerlink" title="是什么: 改变method list SEL 所指向的IMP指针"></a>是什么: 改变method list SEL 所指向的IMP指针</h5><ul>
<li>AOP编程 ：<ul>
<li>统计打点</li>
<li>安全检查(字典，数组)</li>
</ul>
</li>
</ul>
<h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p>当<code>objc_msgSend</code>找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p>
<ul>
<li>接收消息的对象（也就是<code>self</code>指向的内容）</li>
<li>方法选择器（<code>_cmd</code>指向的内容）</li>
</ul>
<p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p><code>[super class]</code></p>
<p>最终会转换为</p>
<p><code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>去调用，此时已经和<code>[self class]</code>调用相同了</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>Ivar 在objc中被定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset<span class="comment">// 地址编译量                                       OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                             OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>在编译我们的类时，编译器生成了一个 ivar布局，显示了在类中从哪可以访问我们的 ivars </p>
<p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-14/94404242-file_1484402886263_12112.png" alt=""></p>
<blockquote>
<p>对象的内存布局是 = isa指针 + 父类成员变量+子类成员变量</p>
</blockquote>
<p>我们对 ivar 的访问就可以通过 对象地址 ＋ ivar偏移字节的方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @<span class="keyword">private</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@<span class="string">"current pointer = %p"</span>, self);</span><br><span class="line">    NSLog(@<span class="string">"age pointer = %p"</span>, &amp;age);</span><br><span class="line">    <span class="keyword">return</span> [NSString stringWithFormat:@<span class="string">"age = %d"</span>, age];</span><br><span class="line">&#125;</span><br><span class="line">@<span class="function">end</span><br><span class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        Ivar age_ivar = class_getInstanceVariable(object_getClass(student), <span class="string">"age"</span>);</span><br><span class="line">        <span class="keyword">int</span> *age_pointer = (<span class="keyword">int</span> *)((__bridge <span class="keyword">void</span> *)(student) + ivar_getOffset(age_ivar));</span><br><span class="line">        NSLog(@<span class="string">"age ivar offset = %td"</span>, ivar_getOffset(age_ivar));</span><br><span class="line">        *age_pointer = <span class="number">10</span>;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2014-11-08 18:24:38.892 Test[4143:466864] age ivar offset = 8</span><br><span class="line">2014-11-08 18:24:38.893 Test[4143:466864] current pointer = 0x1001002d0</span><br><span class="line">2014-11-08 18:24:38.893 Test[4143:466864] age pointer = 0x1001002d8</span><br><span class="line">2014-11-08 18:24:38.894 Test[4143:466864] age = 10</span><br></pre></td></tr></table></figure>
<p>相关参考文档: </p>
<p><a href="http://www.cnblogs.com/csutanyu/archive/2011/12/12/Objective-C_memory_layout.html" target="_blank" rel="external"><a href="http://www.cnblogs.com/csutanyu/archive/2011/12/12/Objective-C_memory_layout.html" target="_blank" rel="external">Objective-C内存布局</a></a></p>
<p><a href="http://chun.tips/blog/2014/11/06/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(3" target="_blank" rel="external">刨根问底Objective－C Runtime（3）－ 消息 和 Category</a>%5Bnil%5D-xiao-xi-he-category/)</p>
<p><a href="http://www.cocoachina.com/ios/20141224/10740.html" target="_blank" rel="external">刨根问底Objective－C Runtime</a></p>
<p><a href="http://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="external">Objective-C 中的消息与消息转发</a></p>
<p><a href="http://www.cocoachina.com/ios/20150604/12013.html" target="_blank" rel="external">轻松学习之 Objective-C消息转发</a></p>
<p><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a></p>
<p><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="external">Objective-C Runtime 运行时之一：类与对象</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/12/1语法特性/load&&initialize/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/12/1语法特性/load&&initialize/" itemprop="url">
                  load && initialize
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-12T16:32:39+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="load-amp-amp-initialize"><a href="#load-amp-amp-initialize" class="headerlink" title="load &amp;&amp; initialize"></a>load &amp;&amp; initialize</h4><ul>
<li>load</li>
</ul>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
</blockquote>
<p>从上面的描述可以看出这个方法调用的时机很早，在类(分类)被加载到runtime的时候就会调用，同时只有类实现了这个方法才能被响应。</p>
<ul>
<li>initialize</li>
</ul>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. </p>
</blockquote>
<p>不同于load，initialize只有在类或者它的子类第一次接收到消息之前才会调用,相当于懒加载。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    [super initialize];</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__func__,[self class]);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Dog : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    [super initialize];</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在main.m文件里执行上述代码，可以输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Animal load]</span><br><span class="line">+[Dog load] </span><br><span class="line">main</span><br></pre></td></tr></table></figure>
<p>可以看出在没有主动对类执行操作情况下，load会默认执行，并且在main函数之前执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__func__,[self class]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    Dog *dog = [[Dog alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行结果: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Animal load]</span><br><span class="line">+[Animal initialize] Animal</span><br><span class="line">+[Animal initialize] Dog</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出initialize明显的一个特点是当子类没有实现的时候，它会主动调用父类的方法，而load并没有这一特性，为了解释这一特性，我们得从runtime源码层面剖析: </p>
<p>load方法的调用核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Call all +loads for the detached list.</span><br><span class="line">for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">    Class cls = classes[i].cls;</span><br><span class="line">    load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">    if (!cls) continue;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    (*load_method)(cls, SEL_load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码循环调用所有类的 +load 方法。<strong>注意</strong>，这里是（调用分类的 +load 方法也是如此）直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 对 +load 方法进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。</p>
<p>这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Class supercls;</span><br><span class="line">    BOOL reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    monitor_enter(&amp;classInitLock);</span><br><span class="line">    if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">        cls-&gt;setInitializing();</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    monitor_exit(&amp;classInitLock);</span><br><span class="line"></span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line"></span><br><span class="line">        // Record that we&apos;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&apos;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有两个关键点: </p>
<ul>
<li>入参的父类进行了递归调用，以确保父类优先于子类初始化</li>
<li>runtime 使用了发送消息 <code>objc_msgSend</code>的方式对 +initialize 方法进行调用。也就是说 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>load</p>
<blockquote>
<p>method swizzling</p>
</blockquote>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>两者在runtime都是递归调用，父类先于子类被调用</li>
<li>load根据函数地址发送，(分类.子类，父类调用分开)  initialise(懒加载) meg_send发送 (子类没有实现会查找父亲的方法列表，分类覆盖所属类的实现)</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时</td>
<td>收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>若自身未定义，是否沿用父类的方法？</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
<p>参考: </p>
<p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">Objective-C +load vs +initialize</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/11/编译器/静态语言&& 动态语言/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/11/编译器/静态语言&& 动态语言/" itemprop="url">
                  静态语言&& 动态语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-11T23:38:06+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来源:</p>
<p><a href="http://www.cnblogs.com/dzhanjie/archive/2011/07/07/2100340.html" target="_blank" rel="external"> 编译型和解释型</a></p>
<p><a href="http://stackoverflow.com/questions/260626/what-is-type-safe" target="_blank" rel="external"><a href="http://stackoverflow.com/questions/260626/what-is-type-safe" target="_blank" rel="external">What is Type-safe?</a></a></p>
<h4 id="编译型和解释型"><a href="#编译型和解释型" class="headerlink" title="编译型和解释型"></a>编译型和解释型</h4><p>我们先看看编译型，其实它和汇编语言是一样的：也是有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码。这个过程说得专业一点，就称为编译（Compile），而负责编译的程序自然就称为编译器（Compiler）。如果我们写的程序代码都包含在一个源文件中，那么通常编译之后就会直接生成一个可执行文件，我们就可以直接运行了。但对于一个比较复杂的项目，为了方便管理，我们通常把代码分散在各个源文件中，作为不同的模块来组织。这时编译各个文件时就会生成目标文件（Object   file）而不是前面说的可执行文件。一般一个源文件的编译都会对应一个目标文件。这些目标文件里的内容基本上已经是可执行代码了，但由于只是整个项目的一部分，所以我们还不能直接运行。待所有的源文件的编译都大功告成，我们就可以最后把这些半成品的目标文件“打包”成一个可执行文件了，这个工作由另一个程序负责完成，由于此过程好像是把包含可执行代码的目标文件连接装配起来，所以又称为链接（Link），而负责链接的程序就叫……就叫链接程序（Linker）。链接程序除了链接目标文件外，可能还有各种资源，像图标文件啊、声音文件啊什么的，还要负责去除目标文件之间的冗余重复代码，等等，所以……也是挺累的。链接完成之后，一般就可以得到我们想要的可执行文件了。</p>
<p>上面我们大概地介绍了编译型语言的特点，现在再看看解释型。噢，从字面上看，“编译”和“解释”的确都有“翻译”的意思，它们的区别则在于翻译的时机安排不大一样。打个比方：假如你打算阅读一本外文书，而你不知道这门外语，那么你可以找一名翻译，给他足够的时间让他从头到尾把整本书翻译好，然后把书的母语版交给你阅读；或者，你也立刻让这名翻译辅助你阅读，让他一句一句给你翻译，如果你想往回看某个章节，他也得重新给你翻译。 </p>
<p>两种方式，前者就相当于我们刚才所说的编译型：一次把所有的代码转换成机器语言，然后写成可执行文件；而后者就相当于我们要说的解释型：在程序运行的前一刻，还只有源程序而没有可执行程序；而程序每执行到源程序的某一条指令，则会有一个称之为解释程序的外壳程序将源代码转换成二进制代码以供执行，总言之，就是不断地解释、执行、解释、执行……所以，解释型程序是离不开解释程序的。像早期的BASIC就是一门经典的解释型语言，要执行BASIC程序，就得进入BASIC环境，然后才能加载程序源文件、运行。解释型程序中，由于程序总是以源代码的形式出现，因此只要有相应的解释器，移植几乎不成问题。编译型程序虽然源代码也可以移植，但前提是必须针对不同的系统分别进行编译，对于复杂的工程来说，的确是一件不小的时间消耗，况且很可能一些细节的地方还是要修改源代码。而且，解释型程序省却了编译的步骤，修改调试也非常方便，编辑完毕之后即可立即运行，不必像编译型程序一样每次进行小小改动都要耐心等待漫长的Compiling…Linking…这样的编译链接过程。不过凡事有利有弊，由于解释型程序是将编译的过程放到执行过程中，这就决定了解释型程序注定要比编译型慢上一大截，像几百倍的速度差距也是不足为奇的。 </p>
<p>编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object   Pascal（Delphi）、VB等基本都可视为编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python等等。 </p>
<p>但既然编译型与解释型各有优缺点又相互对立，所以一批新兴的语言都有把两者折衷起来的趋势，例如Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。而像VB6（或者以前版本）、C#这样的语言，虽然表面上看生成的是.exe可执行程序文件，但VB6编译之后实际生成的也是一种中介码，只不过编译器在前面安插了一段自动调用某个外部解释器的代码（该解释程序独立于用户编写的程序，存放于系统的某个DLL文件中，所有以VB6编译生成的可执行程序都要用到它），以解释执行实际的程序体。C#（以及其它.net的语言编译器）则是生成.net目标代码，实际执行时则由.net解释系统（就像JVM一样，也是一个虚拟机平台）进行执行。当然.net目标代码已经相当“低级”，比较接近机器语言了，所以仍将其视为编译语言，而且其可移植程度也没有Java号称的这么强大，Java号称是“一次编译，到处执行”，而.net则是“一次编码，到处编译”。呵呵，当然这些都是题外话了。总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。</p>
<h4 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h4><p>　通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。</p>
<p>（1）动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</p>
<p>（2）静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</p>
<p>对于动态语言与静态语言的区分，套用一句流行的话就是：Static typing when possible, dynamic typing when needed。</p>
<blockquote>
<p>批阅： </p>
<p>动态:运行期检查类型，你编写的时候不用指定类型</p>
<p>静态: 编译期检查类型，你编写的时候要指定好类型</p>
</blockquote>
<h4 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h4><p>Type safety means that the compiler will validate types while compiling, and throw an error if you try to assign the wrong type to a variable.</p>
<p>Some simple examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Fails, Trying to put an integer in a string</span><br><span class="line">String one = 1;</span><br><span class="line">// Also fails.</span><br><span class="line">int foo = &quot;bar&quot;;</span><br></pre></td></tr></table></figure>
<p>This also applies to method arguments, since you are passing explicit types to them:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int AddTwoNumbers(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If I tried to call that using:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Sum = AddTwoNumbers(5, &quot;5&quot;);</span><br></pre></td></tr></table></figure>
<p>The compiler would throw an error, because I am passing a string (“5”), and it is expecting an integer.</p>
<p>In a loosely typed language, such as javascript, I can do the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function AddTwoNumbers(a, b)</span><br><span class="line">&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if I call it like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum = AddTwoNumbers(5, &quot;5&quot;);</span><br></pre></td></tr></table></figure>
<p>Javascript automaticly converts the 5 to a string, and returns “55”. This is due to javascript using the + sign for string concatenation. To make it type-aware, you would need to do something like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function AddTwoNumbers(a, b)</span><br><span class="line">&#123;</span><br><span class="line">    return Number(a) + Number(b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>if I call it like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum = AddTwoNumbers(5, &quot; dogs&quot;);</span><br></pre></td></tr></table></figure>
<p>Javascript automatically converts the 5 to a string, and appends them, to return “5 dogs”.</p>
<p>Not all dynamic languages are as forgiving as javascript (In fact a dynamic language does not implicity imply a loose typed language (see Python)), some of them will actually give you a runtime error on invalid type casting.</p>
<p>While its convenient, it opens you up to a lot of errors that can be easily missed, and only identified by testing</p>
<blockquote>
<p>批阅: 编译或者运行期检查类型，如果类型不匹配抛出一个错误</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/12/11/1性能优化/性能优化/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/11/1性能优化/性能优化/" itemprop="url">
                  性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-11T13:18:36+08:00">
                2015-12
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="显示原理"><a href="#显示原理" class="headerlink" title="显示原理"></a>显示原理</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-20/95673407-file_1484905412627_29bc.png" alt=""></p>
<ol>
<li>CPU 计算好显示内容，如视图的创建、布局计算、图片解码、文本绘制等。随后CPU将计算好的内容提交到GPU</li>
<li>GPU进行变换,合成，渲染， 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</li>
</ol>
<h4 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因:"></a>卡顿产生的原因:</h4><p><img src="http://ohbzayk4i.bkt.clouddn.com/17-1-21/41214618-file_1484935773331_2c20.jpg" alt=""></p>
<ol>
<li>当显示器的电子扫描枪回到原位，准备下一帧扫描的时候，会付出一个Vsync，</li>
<li>当vsync开始下一帧扫描的时候，GPU没有把完成渲染放到帧缓冲区，那一帧就会被废弃，这就是所谓的掉帧</li>
</ol>
<blockquote>
<p>总结:显示器秒回产生60个垂直同步信号，如果在信号间隔cpu 和 gpu 没有把要显示的内容准备好，那一帧就会被废弃掉，产生掉帧，这也是卡顿的原因</p>
</blockquote>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><blockquote>
<p>保持CPU和GPU负载均衡</p>
</blockquote>
<h5 id="减少CPU的负载"><a href="#减少CPU的负载" class="headerlink" title="减少CPU的负载:"></a>减少CPU的负载:</h5><p><strong>方法</strong>:空间换时间</p>
<ul>
<li><p>对象的创建: 提前创建好 </p>
</li>
<li><p>布局(文本)的计算，做缓存</p>
</li>
<li><p>图像的解码: </p>
<blockquote>
<p>Once an image file has been loaded, it must then be decompressed. This decompression can be a computationally complex task and take considerable time. The decompressed image will also use substantially more memory thane the original</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路:开启子线程解码，参考sdwebimage的 的 decodedImageWithImage方法</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h5 id="减少GPU的负载"><a href="#减少GPU的负载" class="headerlink" title="减少GPU的负载:"></a>减少GPU的负载:</h5><ol>
<li><p>减少视图的混合，减少透明视图的混合</p>
</li>
<li><p>减少离屏渲染</p>
<p>​</p>
</li>
</ol>
<p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>
<p><a href="https://gold.xitu.io/post/58667d86128fe10057eae0d2" target="_blank" rel="external">iOS 页面性能优化</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/11/12/1语法特性/property/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/12/1语法特性/property/" itemprop="url">
                  property
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-12T22:27:40+08:00">
                2015-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>封装实例变量，生成存取方法,由编译器自动合成</p>
<p>property = var+ setter + getter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">@property NSString *name;</span><br><span class="line">@property NSString *lastName;</span><br><span class="line">@end</span><br><span class="line">//----等价于</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">- (NSString *)name;</span><br><span class="line">- (void)setName:(NSString *)name;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="生成关键字种类"><a href="#生成关键字种类" class="headerlink" title="生成关键字种类"></a>生成关键字种类</h4><ul>
<li><p>内存管理</p>
<p>assign, weak,strong,copy</p>
<p>​</p>
</li>
</ul>
<ul>
<li><p>线程安全</p>
<blockquote>
<p>atomic: 加锁， 多线程安全(安全), nonatomic:不加锁</p>
<p>相关伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (void)setProp:(NSString *)newValue &#123;</span><br><span class="line">&gt;     [_prop lock];</span><br><span class="line">&gt;     _prop = newValue;</span><br><span class="line">&gt;     [_prop unlock];</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>atomic 只能保证读写操作的完整性，但是并不能保证线程安全</p>
<p>试想一下这个例子</p>
<p>线程A 和线程B同时对X进行写入操作。</p>
<p>当线程A进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全。</p>
<p>Thread A:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.firstName = @&quot;Rob&quot;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Thread B:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; p.firstName = @&quot;Robert&quot;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Thread A:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; label.string = p.firstName;   // &lt;&lt; uh, oh -- will be Robert</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​</p>
</li>
<li><p>读写</p>
<p>readwrite, readonly</p>
<blockquote>
<p>readonly 不合成setter方法</p>
</blockquote>
</li>
<li><p>命名</p>
<p>for: </p>
<p><code>@property (nonatomic, assign, getter = isOpen) BOOL open;</code></p>
<p>setter的修改方式类似，只是不太常用</p>
</li>
</ul>
<p>参考:</p>
<p><a href="http://stackoverflow.com/questions/12347236/which-is-threadsafe-atomic-or-non-atomic" target="_blank" rel="external">Which is threadsafe atomic or non atomic?</a></p>
<p><a href="http://blog.talisk.cn/blog/2016/03/05/iOS-@property/" target="_blank" rel="external">@property的前世今生</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/11/11/1内存管理/内存管理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/11/1内存管理/内存管理/" itemprop="url">
                  内存管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-11T23:38:06+08:00">
                2015-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>参考: <a href="http://www.cnblogs.com/jsean/articles/1599799.html" target="_blank" rel="external">HEAP和STACK的区别</a></p>
<p><a href="http://c.biancheng.net/cpp/biancheng/view/141.html" target="_blank" rel="external">C++变量的存储类别（动态存储、静态存储、自动变量、寄存器变量、外部变量）</a></p>
<p><a href="http://www.myexception.cn/c/1910454.html" target="_blank" rel="external">C语言堆跟栈</a></p>
<p><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=712" target="_blank" rel="external">iOS内存管理：从MRC到ARC实践</a></p>
<p><strong>自动变量</strong>（<em>Automatic Variable</em>）指的是局部<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="external">作用域</a><a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="external">变量</a>)， 具体来说即是在<a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E6%B5%81" target="_blank" rel="external">控制流</a>进入变量作用域时系统自动为其<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" target="_blank" rel="external">分配存储空间</a>，并在离开作用域时释放空间的一类变量。在许多<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AA%9E%E8%A8%80" target="_blank" rel="external">程序语言</a>中，自动变量与术语“<a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="external">局部变量</a>”（<em>Local Variable</em>）所指的变量实际上是同一种变量。</p>
<h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>栈区： 系统自动分配并释放的， 存放局部变量和形参 ，用栈的方式操作(fifo)，连续,由编译器自动分配和释放</p>
<p>堆区：由程序员手动创建并释放，存放对象 ， 用链表方式记录空闲地址，不连续</p>
<p>全局区(静态区)：全局变量和静态变量</p>
<p>常量区: 存放常量字符串，程序结束后由系统释放</p>
<p>代码区：存放二进制代码</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&amp;_=5707006" alt=""></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main.cpp </span><br><span class="line">　　int a = 0; 全局初始化区 </span><br><span class="line">　　char *p1; 全局未初始化区 </span><br><span class="line">　　main() </span><br><span class="line">　　&#123; </span><br><span class="line">　　int b; 栈 </span><br><span class="line">　　char s[] = "abc"; 栈 </span><br><span class="line">　　char *p2; 栈 </span><br><span class="line">　　char *p3 = "123456"; 123456\0在常量区，p3在栈上。 </span><br><span class="line">　　static int c =0； 全局（静态）初始化区 </span><br><span class="line">　　p1 = (char *)malloc(10);  分配得来得10字节的区域在堆区 </span><br><span class="line">　　p2 = (char *)malloc(20);  分配得来得20字节的区域在堆区 </span><br><span class="line">   strcpy(p1,   "123456");   123456\0放在常量区，编译器可能会将它与p3所指向的"12345   </span><br><span class="line">  6"优化成一块。</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>栈的存储</strong>：</p>
<p>在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>　　当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 </p>
</blockquote>
<h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC:"></a>MRC:</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>苹果为了简化内存管理，设计一套简单的内存管理规则。在这个规则下 <strong>内存对象由系统去处理释放的问题</strong></p>
<p>创建者和持有者处理好自己的问题</p>
<ul>
<li><p>谁创建，谁释放 (alloc , new ,copy，mutable copy ，<strong>或者以这些关键字开头的自定义初始化方法</strong>)</p>
<blockquote>
<p><strong>如果创建一个方法，在方法里返回一个对象，非以上关键字命名的，那这个方法应该怎么写呢?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; - (id)object&#123;</span><br><span class="line">&gt;     id obj = [[NSObject alloc]  init];</span><br><span class="line">&gt;     [obj autorelease]; // 在一个runloop周期后被释放</span><br><span class="line">&gt;</span><br><span class="line">&gt;     return object</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>谁持有，谁释放(retain)</p>
</li>
</ul>
<h5 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h5><p>引用计数表(哈希表)</p>
<p>记录对象的内存地址和引用数量。当对象的引用计数器数量是0的时候，对象被销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (retainCount== <span class="number">0</span>) &#123;</span><br><span class="line">  	[self delloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><p>weak的实现</p>
<p>weak 和assign 都表示非拥有，weak会在 对象释放的时候，指向nil，安全</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	id __weak obj1 = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">&#123;</span><br><span class="line">  id obj1</span><br><span class="line">  obj1 = <span class="number">0</span>;</span><br><span class="line">  objc_storeweak(&amp;obj1,obj)</span><br><span class="line">  objc_storeweak(&amp;obj1,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">思路： </span><br><span class="line"><span class="number">1.</span> objc_storeweak以对象的内存地址为key，以weak变量的地址为value，注册到weak表中</span><br><span class="line"><span class="number">2</span>， 如果第二个参数为<span class="number">0</span>(当对象没有强引用的时候)，则同样以对象的内存地址为key，通过weak表找到weak变量 ，将他们赋值为nil，从weak表中删除</span><br></pre></td></tr></table></figure>
<p>启示：weak操作会消耗cpu资源，建议只在循环引用时候使用</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/10/17/数据结构&&算法/观察者/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/17/数据结构&&算法/观察者/" itemprop="url">
                  观察者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-17T19:35:27+08:00">
                2015-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>什么是数据结构</p>
</blockquote>
<p>数据元素的集合，这些数据元素存在一种或者多种数据关系</p>
<ol>
<li><p>关系</p>
<p>| 逻辑结构 | 物理结构   |<br>| —- | —— |<br>| 集合结构 | 顺序存储结构 |<br>| 线性结构 | 链接存储结构 |<br>| 树形结构 |        |<br>| 图形结构 |        |</p>
<p>​</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/10/17/观察者/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/17/观察者/" itemprop="url">
                  观察者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-17T19:35:27+08:00">
                2015-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="观察者模式定义-发布-订阅模式"><a href="#观察者模式定义-发布-订阅模式" class="headerlink" title="观察者模式定义(发布-订阅模式)"></a>观察者模式定义(发布-订阅模式)</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/200909/200909141252899046109.png" alt=""></h4><p>主题: 一个具体主题实现主题接口方法，主要包括，注册，移除，通知方法</p>
<p>观察者: 具体观察者实现update以便接收时间</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.(定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于他的对象都会得到通知并被自动更新。)</p>
</blockquote>
<h4 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h4><h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h5><blockquote>
<p>  通知机制中对某个感兴趣的所有对象都可以成为接受者。首先，需要对象向通知中心（NSNotificationCenter）发出addObserver:selector:name:object:消息进行注册，在投送对象投送通知给消息中心时，通知中心会把通知广播给注册过的接收者。所有的接收者都不知道是谁投送的，更不关心它的细节。投送对象与接收者是一对多关系。接收者如果对通知不再关注</p>
</blockquote>
<p><img src="http://jbcdn2.b0.upaiyun.com/2014/01/5cb6c1777313e3ca9bfb58053461f71f.jpg" alt=""></p>
<h5 id="kvo"><a href="#kvo" class="headerlink" title="kvo"></a>kvo</h5><blockquote>
<p>  KVO不想通知机制那样通过一个通知中心通知所有观察者对象，而是在对象属性变化时通知会被直接发送给观察者对象。</p>
</blockquote>
<p><img src="http://img1.tuicool.com/yA32Uj.jpg!web" alt=""></p>
<p><a href="http://www.tuicool.com/articles/ZnuEjm" target="_blank" rel="external">设计模式深入学习IOS版（7）观察者模式</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="atony2099.github.io/2015/10/17/数据结构&&算法/算法分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="tony2009">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="托尼的开发笔记">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="托尼的开发笔记" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/17/数据结构&&算法/算法分析/" itemprop="url">
                  时间复杂度
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-17T19:35:27+08:00">
                2015-10
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
</blockquote>
<p>时间频度： 一个算法中语句被执行的次数T(n),不好测量</p>
<p>时间复杂度: </p>
<blockquote>
<p>若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。<br>进一步解释:   T(n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C <em> f(n)。简单来说，**就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时T (n)的上界是C </em> f(n)**</p>
</blockquote>
<p>计算: 一般取最高幂<img src="http://img.blog.csdn.net/20130920210031796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvem9sYWxhZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="external"><a href="http://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="external">算法的时间复杂度和空间复杂度-总结</a></a></p>
<p><a href="http://blog.jobbole.com/100531/" target="_blank" rel="external">坐在马桶上看算法（3）：快速排序</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="tony2009" />
          <p class="site-author-name" itemprop="name">tony2009</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">73</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tony2009</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
