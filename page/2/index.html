<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Seite 2 | 托尼的夏天</title>
  <meta name="author" content="tony2009">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="托尼的夏天"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="托尼的夏天" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
<link rel="stylesheet" href="/css/style.css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://ww1.sinaimg.cn/large/6cea169fjw1edgyzma1xcj21kw16ohba.jpg">
		<a href="/">
			<div class="logo">
				<img src="/logo.png" alt="Profile Picture">
			</div>
			<div id="title">托尼的夏天</div>
		</a>

		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/your_id" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/your_id" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-02-19T09:14:18.000Z"><a href="/2016/02/19/block/">Fri, Feb 19 2016, 5:14:18 pm</a></time>

  
    <h1 class="title"><a href="/2016/02/19/block/">block探究</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h4 id="关于闭包"><a href="#关于闭包" class="headerlink" title="关于闭包"></a>关于闭包</h4><blockquote>
<p>闭包:首先，闭包是一个<strong>函数</strong>,它1.定义在函数内部 2.能读取其他函数内部变量</p>
</blockquote>
<p><strong>JS例子</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　alert(n);</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line">　　nAdd();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于=f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<h4 id="block实现"><a href="#block实现" class="headerlink" title="block实现"></a>block实现</h4><blockquote>
<p> block 实际上就是 Objective-C 语言对于闭包的实现。</p>
</blockquote>
<p>block数据结构定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl</span><br><span class="line">&#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int Flags;</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>isa 指针，所有对象都有该指针，用于实现对象相关的功能。</li>
<li>flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</li>
<li>reserved，保留变量。</li>
<li>FuncPtr函数指针，指向 Block 要执行的函数</li>
</ol>
<blockquote>
<p>“<em>Blocks are Objective-C objects, which means they can be added to collections like NSArray or NSDictionary.</em> ”</p>
</blockquote>
<p>###block执行过程</p>
<p>   ​</p>
<p>   block.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ^&#123; <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>); &#125; ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clang -rewrite-objc block.c 翻译后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA) ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，block的代码可以表示为: </p>
<p><img src="data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%20standalone%3D%22no%22%3F%3E%3C!DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%2020010904%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FTR%2F2001%2FREC-SVG-20010904%2FDTD%2Fsvg10.dtd%22%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22559%22%20height%3D%22458%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Csource%3E%3C!%5BCDATA%5BCreated%20with%20Rapha%C3%ABl%202.1.2main(" alt="">%E8%B0%83%E7%94%A8%20<strong>main_block_impl_0%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93</strong>main_block_impl_0%EF%BC%88<strong>main_block_func_0%20%2C%20</strong>main_block_desc_0_DATA%EF%BC%89%3B%E5%BE%97%E5%88%B0%E7%9A%84<strong>main_block_impl_0%20%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%BB%99%20blk%E6%89%A7%E8%A1%8C%20blk-%3EFuncPtr()%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3%20printf(%22Block%5Cn%22)%3BEnd%5D%5D%3E%3C%2Fsource%3E%3Cdesc%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3ECreated%20with%20Rapha%C3%ABl%202.1.2%3C%2Fdesc%3E%3Cdefs%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3Cpath%20stroke-linecap%3D%22round%22%20d%3D%22M5%2C0%200%2C2.5%205%2C5z%22%20id%3D%22raphael-marker-block%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3C%2Fpath%3E%3Cmarker%20id%3D%22raphael-marker-endblock33%22%20markerHeight%3D%223%22%20markerWidth%3D%223%22%20orient%3D%22auto%22%20refX%3D%221.5%22%20refY%3D%221.5%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3Cuse%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20xlink%3Ahref%3D%22%23raphael-marker-block%22%20transform%3D%22rotate(180%201.5%201.5)%20scale(0.6%2C0.6)%22%20stroke-width%3D%221.6667%22%20fill%3D%22black%22%20stroke%3D%22none%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3C%2Fuse%3E%3C%2Fmarker%3E%3C%2Fdefs%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%2262.5%22%20height%3D%2236.65625%22%20r%3D%2220%22%20rx%3D%2220%22%20ry%3D%2220%22%20fill%3D%22%23ffffff%22%20stroke%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%20stroke-width%3D%222%22%20class%3D%22flowchart%22%20id%3D%22start%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C249.3984%2C12.9219)%22%3E%3C%2Frect%3E%3Ctext%20x%3D%2210%22%20y%3D%2218.328125%22%20text-anchor%3D%22start%22%20font%3D%2210px%20%26quot%3BArial%26quot%3B%22%20stroke%3D%22none%22%20fill%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%20text-anchor%3A%20start%3B%20font-style%3A%20normal%3B%20font-variant%3A%20normal%3B%20font-weight%3A%20normal%3B%20font-stretch%3A%20normal%3B%20font-size%3A%2015px%3B%20line-height%3A%20normal%3B%20font-family%3A%20Arial%3B%22%20id%3D%22startt%22%20class%3D%22flowchartt%22%20font-size%3D%2215px%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C249.3984%2C12.9219)%22%3E%3Ctspan%20dy%3D%225.171875%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3Emain()%3C%2Ftspan%3E%3C%2Ftext%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22553.296875%22%20height%3D%2254.5%22%20r%3D%220%22%20rx%3D%220%22%20ry%3D%220%22%20fill%3D%22%23ffffff%22%20stroke%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%20stroke-width%3D%222%22%20class%3D%22flowchart%22%20id%3D%22op1%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C4%2C103.5781)%22%3E%3C%2Frect%3E%3Ctext%20x%3D%2210%22%20y%3D%2227.25%22%20text-anchor%3D%22start%22%20font%3D%2210px%20%26quot%3BArial%26quot%3B%22%20stroke%3D%22none%22%20fill%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%20text-anchor%3A%20start%3B%20font-style%3A%20normal%3B%20font-variant%3A%20normal%3B%20font-weight%3A%20normal%3B%20font-stretch%3A%20normal%3B%20font-size%3A%2015px%3B%20line-height%3A%20normal%3B%20font-family%3A%20Arial%3B%22%20id%3D%22op1t%22%20class%3D%22flowchartt%22%20font-size%3D%2215px%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C4%2C103.5781)%22%3E%3Ctspan%20dy%3D%22-3.75%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%E8%B0%83%E7%94%A8%20</strong>main_block_impl_0%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%3C%2Ftspan%3E%3Ctspan%20dy%3D%2218%22%20x%3D%2210%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E<strong>main_block_impl_0%EF%BC%88</strong>main_block_func_0%20%2C%20<strong>main_block_desc_0_DATA%EF%BC%89%3B%3C%2Ftspan%3E%3C%2Ftext%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22342.59375%22%20height%3D%2236.5%22%20r%3D%220%22%20rx%3D%220%22%20ry%3D%220%22%20fill%3D%22%23ffffff%22%20stroke%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%20stroke-width%3D%222%22%20class%3D%22flowchart%22%20id%3D%22op2%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C109.3516%2C221.0781)%22%3E%3C%2Frect%3E%3Ctext%20x%3D%2210%22%20y%3D%2218.25%22%20text-anchor%3D%22start%22%20font%3D%2210px%20%26quot%3BArial%26quot%3B%22%20stroke%3D%22none%22%20fill%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%20text-anchor%3A%20start%3B%20font-style%3A%20normal%3B%20font-variant%3A%20normal%3B%20font-weight%3A%20normal%3B%20font-stretch%3A%20normal%3B%20font-size%3A%2015px%3B%20line-height%3A%20normal%3B%20font-family%3A%20Arial%3B%22%20id%3D%22op2t%22%20class%3D%22flowchartt%22%20font-size%3D%2215px%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C109.3516%2C221.0781)%22%3E%3Ctspan%20dy%3D%225.25%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%E5%BE%97%E5%88%B0%E7%9A%84</strong>main_block_impl_0%20%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%BB%99%20blk%3C%2Ftspan%3E%3C%2Ftext%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22321.109375%22%20height%3D%2236.65625%22%20r%3D%220%22%20rx%3D%220%22%20ry%3D%220%22%20fill%3D%22%23ffffff%22%20stroke%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%20stroke-width%3D%222%22%20class%3D%22flowchart%22%20id%3D%22op3%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C120.0938%2C320.5)%22%3E%3C%2Frect%3E%3Ctext%20x%3D%2210%22%20y%3D%2218.328125%22%20text-anchor%3D%22start%22%20font%3D%2210px%20%26quot%3BArial%26quot%3B%22%20stroke%3D%22none%22%20fill%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%20text-anchor%3A%20start%3B%20font-style%3A%20normal%3B%20font-variant%3A%20normal%3B%20font-weight%3A%20normal%3B%20font-stretch%3A%20normal%3B%20font-size%3A%2015px%3B%20line-height%3A%20normal%3B%20font-family%3A%20Arial%3B%22%20id%3D%22op3t%22%20class%3D%22flowchartt%22%20font-size%3D%2215px%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C120.0938%2C320.5)%22%3E%3Ctspan%20dy%3D%225.171875%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%E6%89%A7%E8%A1%8C%20blk-%26gt%3BFuncPtr()%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3%20printf(%22Block%5Cn%22)%3B%3C%2Ftspan%3E%3C%2Ftext%3E%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%2246.6875%22%20height%3D%2236.5%22%20r%3D%2220%22%20rx%3D%2220%22%20ry%3D%2220%22%20fill%3D%22%23ffffff%22%20stroke%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%20stroke-width%3D%222%22%20class%3D%22flowchart%22%20id%3D%22end%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C257.3047%2C420.1563)%22%3E%3C%2Frect%3E%3Ctext%20x%3D%2210%22%20y%3D%2218.25%22%20text-anchor%3D%22start%22%20font%3D%2210px%20%26quot%3BArial%26quot%3B%22%20stroke%3D%22none%22%20fill%3D%22%23000000%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%20text-anchor%3A%20start%3B%20font-style%3A%20normal%3B%20font-variant%3A%20normal%3B%20font-weight%3A%20normal%3B%20font-stretch%3A%20normal%3B%20font-size%3A%2015px%3B%20line-height%3A%20normal%3B%20font-family%3A%20Arial%3B%22%20id%3D%22endt%22%20class%3D%22flowchartt%22%20font-size%3D%2215px%22%20transform%3D%22matrix(1%2C0%2C0%2C1%2C257.3047%2C420.1563)%22%3E%3Ctspan%20dy%3D%225.25%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3EEnd%3C%2Ftspan%3E%3C%2Ftext%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23000000%22%20d%3D%22M280.6484375%2C49.578125C280.6484375%2C49.578125%2C280.6484375%2C89.23222494125366%2C280.6484375%2C100.57856408460066%22%20stroke-width%3D%222%22%20marker-end%3D%22url(%23raphael-marker-endblock33)%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23000000%22%20d%3D%22M280.6484375%2C158.078125C280.6484375%2C158.078125%2C280.6484375%2C205.56178188323975%2C280.6484375%2C218.08188672550023%22%20stroke-width%3D%222%22%20marker-end%3D%22url(%23raphael-marker-endblock33)%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23000000%22%20d%3D%22M280.6484375%2C257.578125C280.6484375%2C257.578125%2C280.6484375%2C305.00289838016033%2C280.6484375%2C317.5074772987573%22%20stroke-width%3D%222%22%20marker-end%3D%22url(%23raphael-marker-endblock33)%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3C%2Fpath%3E%3Cpath%20fill%3D%22none%22%20stroke%3D%22%23000000%22%20d%3D%22M280.6484375%2C357.15625C280.6484375%2C357.15625%2C280.6484375%2C404.63990688323975%2C280.6484375%2C417.1600117255002%22%20stroke-width%3D%222%22%20marker-end%3D%22url(%23raphael-marker-endblock33)%22%20style%3D%22-webkit-tap-highlight-color%3A%20rgba(0%2C%200%2C%200%2C%200)%3B%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E)</p>
<p>#####block获取外部变量</p>
<p>block.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************* 使用 __block 的源码 *************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123; <span class="built_in">printf</span>(<span class="string">"intValue = %d\n"</span>, intValue); &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clang -rewrite-objc block.c 翻译后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************* 使用 clang 翻译后如下 *************/</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    <span class="keyword">int</span> intValue;</span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _intValue, <span class="keyword">int</span> flags=<span class="number">0</span>) : intValue(_intValue)</span><br><span class="line">    &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = __cself-&gt;intValue; <span class="comment">// bound by copy</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"intValue = %d\n"</span>, intValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, intValue);</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  <code>__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</code></p>
<p>  构造函数 <code>__main_block_impl_0</code> 冒号后的表达式 <code>intValue(_intValue)</code> 的意思是，用 <code>_intValue</code> 初始化结构体成员变量 <code>intValue</code>。</p>
<p>  block首先通过上述构造函数将变量保存到 <code>__main_block_impl_0</code> 结构体的同名变量 <code>intValue</code>，</p>
<p>  然后再通过代码 <code>int intValue = __cself-&gt;intValue;</code> 取出<code>intValue</code>，打印出来</p>
</blockquote>
<h5 id="block访问外部block变量"><a href="#block访问外部block变量" class="headerlink" title="block访问外部block变量"></a>block访问外部block变量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************* 使用 __block 的源码 *************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    __block <span class="keyword">int</span> intValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        intValue = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************* 使用 clang 翻译后如下 *************/</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> __Block_byref_intValue_0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *__isa;</span><br><span class="line">    __Block_byref_intValue_0 *__forwarding;</span><br><span class="line">    <span class="keyword">int</span> __flags;</span><br><span class="line">    <span class="keyword">int</span> __size;</span><br><span class="line">    <span class="keyword">int</span> intValue;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">    __Block_byref_intValue_0 *intValue; <span class="comment">// by ref</span></span><br><span class="line">    __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, <span class="keyword">int</span> flags=<span class="number">0</span>) : intValue(_intValue-&gt;__forwarding)</span><br><span class="line">    &#123;</span><br><span class="line">        impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        impl.Flags = flags;</span><br><span class="line">        impl.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line">    __Block_byref_intValue_0 *intValue = __cself-&gt;intValue; <span class="comment">// bound by ref</span></span><br><span class="line">    (intValue-&gt;__forwarding-&gt;intValue) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0 *dst, <span class="keyword">struct</span> __main_block_impl_0 *src)</span><br><span class="line">&#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;intValue, (<span class="keyword">void</span>*)src-&gt;intValue, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0 *src)</span><br><span class="line">&#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;intValue, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block _impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123;  <span class="number">0</span>, </span><br><span class="line">                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), </span><br><span class="line">                                __main_block_copy_0, </span><br><span class="line">                                __main_block_dispose_0</span><br><span class="line">                             &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \</span><br><span class="line">    intValue = </span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="keyword">void</span>*)<span class="number">0</span>,</span><br><span class="line">        (__Block_byref_intValue_0 *)&amp;intValue, </span><br><span class="line">        <span class="number">0</span>, </span><br><span class="line">        <span class="keyword">sizeof</span>(__Block_byref_intValue_0), </span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)()) &amp;__main_block_impl_0   \</span><br><span class="line">                (</span><br><span class="line">                    (<span class="keyword">void</span> *)__main_block_func_0,            \</span><br><span class="line">                    &amp;__main_block_desc_0_DATA,              \</span><br><span class="line">                    (__Block_byref_intValue_0 *)&amp;intValue,  \</span><br><span class="line">                    <span class="number">570425344</span>                               \</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了</p>
<blockquote>
<ol>
<li><code>__Block_byref_intValue_0</code> 结构体：用于封装 __block 修饰的外部变量。</li>
<li><code>_Block_object_assign</code> 函数：当 block 从栈拷贝到堆时，调用此函数。</li>
<li><code>_Block_object_dispose</code> 函数：当 block 从堆内存释放时，调用此函数。</li>
</ol>
</blockquote>
<p><code>__Block_byref_intValue_</code>结构体如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 存储 __block 外部变量的结构体</span><br><span class="line">struct __Block_byref_intValue_0</span><br><span class="line">&#123;</span><br><span class="line">    void *__isa; // 对象指针</span><br><span class="line">    __Block_byref_intValue_0 *__forwarding; // 指向自己的指针</span><br><span class="line">    int __flags; // 标志位变量</span><br><span class="line">    int __size; // 结构体大小</span><br><span class="line">    int intValue; // 外部变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对比block 访问_block修饰的外部变量 &amp;&amp;_block修饰的外部变量，我们可以看出: </p>
<p>1.非__block修饰的外部变量，直接捕获的是变量的值，传递给内部的变量</p>
<p>2.__block修饰的外部变量，捕获的是变量的地址，保存在结构体变量中</p>
<h4 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="block的内存管理"></a>block的内存管理</h4><p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_2.png" alt=""></p>
<p>block的常见类型有3种：</p>
<ul>
<li>_NSConcreteGlobalBlock（全局）</li>
<li>_NSConcreteStackBlock（栈）</li>
<li>_NSConcreteMallocBlock（堆）</li>
</ul>
<p><em>_NSConcreteGlobalBlock</em></p>
<blockquote>
<p>1、当 block 字面量写在全局作用域时，即为 <code>global block</code>；<br>2、当 block 字面量不获取任何外部变量时，即为 <code>global block</code>；</p>
</blockquote>
<p>除了上述描述的两种情况，其他形式创建的 block 均为 <code>stack block</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block</span><br><span class="line">typedef int (^blk_t)(int);</span><br><span class="line">for (int rate = 0; rate &lt; 10; ++rate) </span><br><span class="line">&#123;</span><br><span class="line">    blk_t blk = ^(int count)&#123;return rate * count;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上</p>
<p>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************ ARC下编译器自动拷贝block ************/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(^<span class="keyword">blk_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> count)&#123;<span class="keyword">return</span> rate * count;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************* 使用 clang 翻译后如下 *************/</span></span><br><span class="line"><span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">blk_t</span> tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</span><br><span class="line">    tmp = objc_retainBlock(tmp);</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(tmp); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********** objc_retainBlock() 的实现 ***********/</span></span><br><span class="line"><span class="function">id <span class="title">objc_retainBlock</span><span class="params">(id x)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ARR_LOGGING</span></span><br><span class="line">    objc_arr_log(<span class="string">"objc_retain_block"</span>, x);</span><br><span class="line">    ++CompilerGenerated.blockCopies;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create a heap based copy of a Block or simply add a reference to an existing one.</span></span><br><span class="line"><span class="comment">// This must be paired with Block_release to recover memory, even when running</span></span><br><span class="line"><span class="comment">// under Objective-C Garbage Collection.</span></span><br><span class="line">BLOCK_EXPORT <span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *aBlock)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>
<p>通过 <code>objc_retainBlock()</code> 函数拷贝到堆内存，让 <code>tmp</code> 重新指向堆上的 block，然后将 <code>tmp</code> 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。</p>
<blockquote>
<p>对于block属性，苹果推荐我们使用copy关键字，但这arc下不是必须的，正如前面所说，在arc，即使不适用cop关键字，编译器也会自动将block copy到堆区</p>
</blockquote>
<h5 id="block-的循环引用"><a href="#block-的循环引用" class="headerlink" title="block 的循环引用"></a>block 的循环引用</h5><p>一个对象强用用了block,block又强引用了该对象，就会产生循环引用</p>
<blockquote>
<p>由于 <code>self</code> 是 <code>__strong</code> 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有<code>self</code>，而 <code>self</code> 恰好也强引用和持有了 block，就造成了传说中的循环引用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, copy) completionBlock completionBlock;</span><br><span class="line"></span><br><span class="line">//========================================</span><br><span class="line">self.completionBlock = ^ &#123;	</span><br><span class="line">        if (self.success) &#123;</span><br><span class="line">            self.success(self.responseData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note58470_2.png" alt=""></p>
<p>用__weak修饰self打断循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, , copy) completionBlock completionBlock;</span><br><span class="line"></span><br><span class="line">//========================================</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.completionBlock = ^ &#123;</span><br><span class="line">    if (weakSelf.success) &#123;</span><br><span class="line">        weakSelf.success(weakSelf.responseData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">学习Javascript闭包（Closure）</a></p>
<p><a href="https://www.zybuluo.com/MicroCai/note/51116" target="_blank" rel="external">block没那么难（一）：block的实现</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/02/19/block/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2016/02/19/block/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/02/19/block/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-02-07T17:26:58.000Z"><a href="/2016/02/08/atomic/">Mon, Feb 8 2016, 1:26:58 am</a></time>

  
    <h1 class="title"><a href="/2016/02/08/atomic/">nonatomic VS atomic</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>stackoverflow上关于这个问题的讨论:<a href="http://stackoverflow.com/questions/588866/whats-the-difference-between-the-atomic-and-nonatomic-attributes" target="_blank" rel="external">What’s the difference between the atomic and nonatomic attributes?</a></p>
<p>主要在于他们生成的getter 和setter方法有所不同。</p>
<p>对于atomic关键字，相关伪代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (UITextField *) userName &#123;</span><br><span class="line">    </span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">       return _userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) setUserName:(UITextField *)userName &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">      _userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 也就是通过加锁来保证线程安全，能避免线程分配竞争，保证数据操作的完整性</p>
<p>更具体例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic)CGRect domain;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-1.png" alt=""></p>
<p>假如你需要在两条线程上修改domin，如下</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;b&gt;thread 1:&lt;/b&gt; puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);</span><br><span class="line">&gt; &lt;b&gt;thread 2:&lt;/b&gt; puppy.domain = CGRectMake (10.0, 20.0, 30.0, 40.0);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>你只会得到两种结果:</p>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-3.png" alt=""></p>
<p>或者：</p>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-4.png" alt=""></p>
<p>而不会出现:</p>
<p><img src="https://www.bignerdranch.com/img/blog/2013/10/puppyrect-2.png" alt=""></p>
<p>这种混合的状态。</p>
<p>所以我们可以说atomic是一种线程安全的机制，但要注意这种线程安全是局部的，之所以这样说，我们还是来看一个例子更直观：</p>
<p>假如puppy有三个成员变量，那我们在A线程设置它的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puppy.name = @&quot;Hoover&quot;;</span><br><span class="line">puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);</span><br></pre></td></tr></table></figure>
<p>在b线程设置它的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puppy.name = @&quot;Rumpelstiltskin&quot;;</span><br><span class="line">puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);</span><br><span class="line">puppy.housebroken = YES;</span><br></pre></td></tr></table></figure>
<p>我们有可能得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">puppy.name = @&quot;Hoover&quot;;</span><br><span class="line">puppy.housebroken = NO;</span><br><span class="line">puppy.domain = CGRectMake (10.0, 20.0, 30.0, 40.0);</span><br></pre></td></tr></table></figure>
<p>这样一组结果，这组数据是错误的。所以单纯靠atomic并不能保证真正的线程安全。</p>
<p>参考:<a href="https://www.bignerdranch.com/blog/property-values/" target="_blank" rel="external">Property Values</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/02/08/atomic/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2016/02/08/atomic/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/02/08/atomic/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2016-01-06T16:24:48.000Z"><a href="/2016/01/07/copy/">Thu, Jan 7 2016, 12:24:48 am</a></time>

  
    <h1 class="title"><a href="/2016/01/07/copy/">copy探究</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h4 id="1-浅拷贝-amp-amp-深拷贝"><a href="#1-浅拷贝-amp-amp-深拷贝" class="headerlink" title="1. 浅拷贝&amp;&amp;深拷贝"></a>1. 浅拷贝&amp;&amp;深拷贝</h4><p><img src="http://upload-images.jianshu.io/upload_images/1111290-d90c09e5df129a5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1111290-bc1700453091b35d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>
<p>如图所示,浅拷贝只是对指针的复制，而深拷贝不仅复制了指针，而且复制了指针所指向的对象</p>
<h4 id="2-非集合对象和集合对象的复制"><a href="#2-非集合对象和集合对象的复制" class="headerlink" title="2.非集合对象和集合对象的复制"></a>2.非集合对象和集合对象的复制</h4><p>​    例1：对NSString进行<code>copy</code> 和<code>mutableCopy</code>操作</p>
<p><img src="http://i4.piimg.com/567571/6ba311780cc68886.png" alt=""></p>
<p><img src="http://i2.piimg.com/567571/5ef7ea3ff110a20d.png" alt=""></p>
<p>​    例2：对NSMutableString进行<code>copy</code> 和<code>mutableCopy</code>操作</p>
<p><img src="http://i2.piimg.com/567571/8a51f2e1269869c1.png" alt=""></p>
<p><img src="http://i2.piimg.com/567571/272b2ee7212b4f41.png" alt=""></p>
<p><strong>综合以上两个例子,我们可以得出如下结论</strong></p>
<blockquote>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
<p>warnings: 对集合对象(NSArray,NSDictonary…)上面的结论也同样使用，但是对于集合对象里面的元素对象，始终是浅复制，也即只是复制指针。</p>
</blockquote>
<h4 id="Copy关键字的使用"><a href="#Copy关键字的使用" class="headerlink" title="Copy关键字的使用"></a>Copy关键字的使用</h4><p>通常我们声明NSString，NSArray，NSDictonary类型的变量的时候，都是使用copy关键字，这是为什么呢？</p>
<p>stackoverflow有个类似的问题<a href="http://stackoverflow.com/questions/387959/nsstring-property-copy-or-retain" target="_blank" rel="external">NSString property: copy or retain?</a></p>
<blockquote>
<p> For attributes whose type is an immutable value class that conforms to the <code>NSCopying</code> protocol, you almost always should specify <code>copy</code> in your <code>@property</code> declaration. Specifying <code>retain</code>(strong) is something you almost never want in such a situation.</p>
</blockquote>
<p>从根本上说，由于object-c是一门多态的语言，我们声明变量为NSString，NSArray，NSDictonary类型的时候，本意是想变量为不可变类型，但由于父类的指针可以指向子类对象，所有就有可能发生未知的错误，如下: </p>
<p><img src="http://i2.piimg.com/567571/348394d76131ec1c.png" alt=""></p>
<p>上面输出的结果是<code>hi world</code>,而不是我们一开始指定的<code>hello wrold</code>，而如果我们指定关键字为<code>copy</code>, 就能保证name指针指向的是immutableObject，防止数据被篡改而一起不必要的麻烦。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2016/01/07/copy/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2016/01/07/copy/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2016/01/07/copy/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-12-12T08:32:39.000Z"><a href="/2015/12/12/load&&initialize/">Sat, Dec 12 2015, 4:32:39 pm</a></time>

  
    <h1 class="title"><a href="/2015/12/12/load&&initialize/">associated Objects</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h4 id="load-amp-amp-initialize"><a href="#load-amp-amp-initialize" class="headerlink" title="load &amp;&amp; initialize"></a>load &amp;&amp; initialize</h4><ul>
<li>load</li>
</ul>
<blockquote>
<p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
</blockquote>
<p>从上面的描述可以看出这个方法调用的时机很早，在类(分类)被加载到runtime的时候就会调用，同时只有类实现了这个方法才能被响应。</p>
<ul>
<li>initialize</li>
</ul>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. </p>
</blockquote>
<p>不同于load，initialize只有在类或者它的子类第一次接收到消息之前才会调用,相当于懒加载。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    [super initialize];</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__func__,[self class]);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface Dog : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">+ (void)initialize&#123;</span><br><span class="line">    [super initialize];</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在main.m文件里执行上述代码，可以输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Person load]</span><br><span class="line">+[Girl load] </span><br><span class="line">main</span><br></pre></td></tr></table></figure>
<p>可以看出在没有主动对类执行操作情况下，load会默认执行，并且在main函数之前执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;%s &quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;,__func__,[self class]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    Dog *dog = [[Dog alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>执行结果: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[Animal load]</span><br><span class="line">+[Animal initialize] Animal</span><br><span class="line">+[Animal initialize] Dog</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看出initialize明显的一个特点是当子类没有实现的时候，它会主动调用父类的方法，而load并没有这一特性，为了解释这一特性，我们得从runtime源码层面剖析: </p>
<p>load方法的调用核心代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Call all +loads for the detached list.</span><br><span class="line">for (i = 0; i &lt; used; i++) &#123;</span><br><span class="line">    Class cls = classes[i].cls;</span><br><span class="line">    load_method_t load_method = (load_method_t)classes[i].method;</span><br><span class="line">    if (!cls) continue;</span><br><span class="line"></span><br><span class="line">    if (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    (*load_method)(cls, SEL_load);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码循环调用所有类的 +load 方法。<strong>注意</strong>，这里是（调用分类的 +load 方法也是如此）直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 对 +load 方法进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。</p>
<p>这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    Class supercls;</span><br><span class="line">    BOOL reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    // Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    // See note about deadlock above.</span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    monitor_enter(&amp;classInitLock);</span><br><span class="line">    if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">        cls-&gt;setInitializing();</span><br><span class="line">        reallyInitialize = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    monitor_exit(&amp;classInitLock);</span><br><span class="line"></span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        // We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line"></span><br><span class="line">        // Record that we&apos;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        // Send the +initialize message.</span><br><span class="line">        // Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        // this class doesn&apos;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: calling +[%s initialize]&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: finished +[%s initialize]&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有两个关键点: </p>
<ul>
<li><p>入参的父类进行了递归调用，以确保父类优先于子类初始化</p>
</li>
<li><p>runtime 使用了发送消息 <code>objc_msgSend</code>的方式对 +initialize 方法进行调用。也就是说 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时</td>
<td>收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>若自身未定义，是否沿用父类的方法？</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
<p>参考: </p>
<p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">Objective-C +load vs +initialize</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/12/12/load&&initialize/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2015/12/12/load&&initialize/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/12/12/load&&initialize/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-11-28T14:05:59.000Z"><a href="/2015/11/28/APP启动过程探究/">Sat, Nov 28 2015, 10:05:59 pm</a></time>

  
    <h1 class="title"><a href="/2015/11/28/APP启动过程探究/">APP启动过程探究</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p><em>无关文章的事： 我们一生要爱上几个女孩？</em></p>
<p>本文探讨的问题？</p>
<ul>
<li>应用程序的启动过程是怎么样？</li>
<li>应用程序的生命周期是怎么样？</li>
</ul>
<h4 id="应用程序的启动过程"><a href="#应用程序的启动过程" class="headerlink" title="应用程序的启动过程"></a>应用程序的启动过程</h4><p><img src="http://oleb.net/media/xcode-4-2-app-launch-sequence.png" alt=""></p>
<p><em>图片来源外国网友</em></p>
<p>上图比较完整的描绘一个app启动过程，让我们一步一步开始分解</p>
<ul>
<li>main函数执行</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数是程序的入口，app启动时候先执行main函数，main函数再调用UIApplicationMain函数，</p>
<ul>
<li><p>UIApplicationMain函数这做了很多事情，首先他会创建一个UIAPPlication的单例对象，并创建UIApplication对象的代理对象AppDelegate</p>
<blockquote>
<p>苹果已经为把每个应用包装成一个UIApplication对象，但应用每一步运行的细节并不需要开发者关注，只要关注这个应用对象对应的delegate即可，也就是这个“AppDelegate”。通过AppDelegate我们可以知道Application的运行状态，发生了哪些事件。</p>
<p>The <code>UIApplicationDelegate</code> protocol defines methods that are called by the singleton <code>UIApplication</code> object in response to important events in the lifetime of your app.</p>
<p>AppDelegate定义了很多app生命周期中的重要事件</p>
</blockquote>
<p>同时他会载入和解析info.plist文件.</p>
<blockquote>
<p>info.plist是对工程运行期配置的文件，info常见字段有： </p>
<p>   1&gt; Localiztion native development region (CFBundleDevelopmentRegion)-本地化相关;</p>
<pre><code>2&gt; Bundle display name(CFBundleDisplayName)-程序安装后显示的名称,限制在10-12个字符,如果超出,将被显示缩写名称;

3&gt; Icon file(CFBundleIconFile)-app图标名称,一般为Icon.png;

4&gt; Bundle version(CFBundleVersion)-应用程序的版本号,每次往App Store上发布一个新版本时,需要增加这个版本号;

5&gt; Main storyboard file base name(NSMainStoryboardFile)-主storyboard文件名称;

6&gt; Bundle identifier(CFBundleIdentifier)-项目的唯一标识,部署到真机时用到;
</code></pre></blockquote>
</li>
</ul>
<ul>
<li><p>UIApplication 对象创建管理runloop，UIApplication对象通过runloop来处理各种事件，runloop是一个无限循环，使UIApplicationMain()永远不返回</p>
</li>
<li><p>在UIApplication 对象开始处理事件之前，它会给它的代理发送一个消息application:didFinishLaunchingWithOptions:告诉代理对象AppDelegate，程序已经启动.</p>
<p>如果之前info.plist没有指定main stroyboard，这时候我们就需要在该方法里面手动创建keyWindow并设置它的rootViewController，相关代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    self.viewController = [[ViewController alloc] initWithNibName:@&quot;ViewController&quot; bundle:nil];</span><br><span class="line">    self.window.rootViewController = self.viewController;</span><br><span class="line">    [self.window makeKeyAndVisible];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="应用程序的生命周期"><a href="#应用程序的生命周期" class="headerlink" title="应用程序的生命周期"></a>应用程序的生命周期</h4><p>应用程序的状态大概如下: </p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th>运行机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Not Runing</td>
<td>程序没有启动</td>
</tr>
<tr>
<td style="text-align:left">Inactive</td>
<td>过渡的状态，或者被系统打断(短信，电话), ，应用程序不接收消息或事件</td>
</tr>
<tr>
<td style="text-align:left">Active</td>
<td>前台运行的正常状态,能够接收消息和事件</td>
</tr>
<tr>
<td style="text-align:left">Background</td>
<td>进入后台的状态，不会停留太久就会进如挂起状态</td>
</tr>
<tr>
<td style="text-align:left">suspended</td>
<td>程序在暂停时不能执行代码、但是不会被释放内存。但是当系统内存不足的情况下，暂停的程序有可能会被释放。</td>
</tr>
</tbody>
</table>
<p><img src="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Art/app_interruptions_2x.png" alt=""></p>
<p>初次启动：</p>
<p><code>applicationdidFinishLaunchingWithOptions</code><br><code>applicationDidBecomeActive</code></p>
<p>按下home键：</p>
<p><code>applicationWillResignActive</code><br><code>applicationDidEnterBackground</code></p>
<p><code>applicationWillTerminate</code> // 即将推出</p>
<p>点击APP重新进入：</p>
<p><code>applicationWillEnterForeground</code><br><code>applicationDidBecomeActive</code></p>
<p>参考文档: </p>
<p><a href="http://blog.csdn.net/yang8456211/article/details/11662891" target="_blank" rel="external">iOS application生命周期研究、发现与总结</a></p>
<p><a href="http://oleb.net/blog/2012/02/app-launch-sequence-ios-revisited/" target="_blank" rel="external">Revisiting the App Launch Sequence on iOS</a></p>
<p><a href="http://www.molotang.com/articles/1254.html" target="_blank" rel="external">iOS应用程序的状态及其切换（生命周期)</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/11/28/APP启动过程探究/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2015/11/28/APP启动过程探究/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/11/28/APP启动过程探究/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-10-17T11:35:27.000Z"><a href="/2015/10/17/观察者/">Sat, Oct 17 2015, 7:35:27 pm</a></time>

  
    <h1 class="title"><a href="/2015/10/17/观察者/">观察者模式</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <h4 id="观察者模式定义-发布-订阅模式"><a href="#观察者模式定义-发布-订阅模式" class="headerlink" title="观察者模式定义(发布-订阅模式)"></a>观察者模式定义(发布-订阅模式)</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://img1.51cto.com/attachment/200909/200909141252899046109.png" alt=""></h4><p>主题: 一个具体主题实现主题接口方法，主要包括，注册，移除，通知方法</p>
<p>观察者: 具体观察者实现update以便接收时间</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.(定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于他的对象都会得到通知并被自动更新。)</p>
</blockquote>
<h4 id="观察者模式的实现"><a href="#观察者模式的实现" class="headerlink" title="观察者模式的实现"></a>观察者模式的实现</h4><h5 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h5><blockquote>
<p>  通知机制中对某个感兴趣的所有对象都可以成为接受者。首先，需要对象向通知中心（NSNotificationCenter）发出addObserver:selector:name:object:消息进行注册，在投送对象投送通知给消息中心时，通知中心会把通知广播给注册过的接收者。所有的接收者都不知道是谁投送的，更不关心它的细节。投送对象与接收者是一对多关系。接收者如果对通知不再关注</p>
</blockquote>
<p><img src="http://jbcdn2.b0.upaiyun.com/2014/01/5cb6c1777313e3ca9bfb58053461f71f.jpg" alt=""></p>
<h5 id="kvo"><a href="#kvo" class="headerlink" title="kvo"></a>kvo</h5><blockquote>
<p>  KVO不想通知机制那样通过一个通知中心通知所有观察者对象，而是在对象属性变化时通知会被直接发送给观察者对象。</p>
</blockquote>
<p><img src="http://img1.tuicool.com/yA32Uj.jpg!web" alt=""></p>
<p><a href="http://www.tuicool.com/articles/ZnuEjm" target="_blank" rel="external">设计模式深入学习IOS版（7）观察者模式</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/10/17/观察者/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2015/10/17/观察者/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/10/17/观察者/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-09-19T06:36:32.000Z"><a href="/2015/09/19/函数式编程/">Sat, Sep 19 2015, 2:36:32 pm</a></time>

  
    <h1 class="title"><a href="/2015/09/19/函数式编程/">函数式编程</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>####概念</p>
<blockquote>
<p>函数式编程是一种编程规范，也就是如何编写方程的方法论，主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式。</p>
<p>　　(1 + 2) * 3 - 4</p>
</blockquote>
<p>传统的过程式编程，可能这样写：</p>
<blockquote>
<p>　　var a = 1 + 2;</p>
<p>　　var b = a * 3;</p>
<p>　　var c = b - 4;</p>
</blockquote>
<p>函数式编程要求使用函数，我们可以把运算过程<a href="http://lostechies.com/derickbailey/2012/01/24/some-thoughts-on-functional-javascript/" target="_blank" rel="external">定义</a>为不同的函数，然后写成下面这样：</p>
<blockquote>
<p>　　var result = subtract(multiply(add(1,2), 3), 4);</p>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>函数式编程具有五个鲜明的特点。</p>
<p><strong>1. 函数是”第一等公民”</strong></p>
<p>所谓<a href="http://en.wikipedia.org/wiki/First-class_function" target="_blank" rel="external">“第一等公民”</a>（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p>
<blockquote>
<p>　　var print = function(i){ console.log(i);};<br>　　[1,2,3].forEach(print);</p>
</blockquote>
<p><strong>2. 只用”表达式”，不用”语句”</strong></p>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>
<p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p>
<p>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p>
<p><strong>3. 没有”副作用”</strong></p>
<p>所谓<a href="http://en.wikipedia.org/wiki/Side_effect_(computer_science" target="_blank" rel="external">“副作用”</a>)（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>
<p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>
<p><strong>4. 不修改状态</strong></p>
<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
<p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的”状态”。</p>
<blockquote>
<p>　　function reverse(string) {</p>
<p>　　　　if(string.length == 0) {</p>
<p>　　　　　　return string;</p>
<p>　　　　} else {</p>
<p>　　　　　　return reverse(string.substring(1, string.length)) + string.substring(0, 1);</p>
<p>　　　　}</p>
<p>　　}</p>
</blockquote>
<p>由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。</p>
<p><strong>5. 引用透明</strong></p>
<p>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p>
<p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>函数式编程到底有什么好处，为什么会变得越来越流行？</p>
<p><strong>1. 代码简洁，开发快速</strong></p>
<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
<p>Paul Graham在<a href="http://www.ruanyifeng.com/docs/pg/" target="_blank" rel="external">《黑客与画家》</a>一书中<a href="http://www.ruanyifeng.com/blog/2010/10/why_lisp_is_superior.html" target="_blank" rel="external">写道</a>：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。</p>
<p>如果程序员每天所写的代码行数基本相同，这就意味着，”C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。”当然，这样的对比故意夸大了差异，但是”在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。”</p>
<p><strong>2. 接近自然语言，易于理解</strong></p>
<p>函数式编程的自由度很高，可以写出很接近自然语言的代码。</p>
<p>前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：</p>
<blockquote>
<p>　　subtract(multiply(add(1,2), 3), 4)</p>
</blockquote>
<p>对它进行变形，不难得到另一种写法：</p>
<blockquote>
<p>　　add(1,2).multiply(3).subtract(4)</p>
</blockquote>
<p>这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：</p>
<blockquote>
<p>　　merge([1,2],[3,4]).sort().search(“2”)</p>
</blockquote>
<p><strong>参考</strong></p>
<p><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程初探</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/09/19/函数式编程/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2015/09/19/函数式编程/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/09/19/函数式编程/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-03-12T14:27:40.000Z"><a href="/2015/03/12/面向对象/">Thu, Mar 12 2015, 10:27:40 pm</a></time>

  
    <h1 class="title"><a href="/2015/03/12/面向对象/">聚合与耦合</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>本文来源: <a href="http://www.nowamagic.net/program/program_PolymerizationAndCoupling.php" target="_blank" rel="external">面向对象编程中的聚合与耦合</a> </p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><blockquote>
<p>聚合（Cohesion）是一个模块内部各成分之间相关联程度的度量。</p>
</blockquote>
<p>这里有多个含义值得考虑。首先，聚合是对一个模块内部的度量，这也是许多情况下我们把聚合称之为内聚的原因。第二，这里出现的模块是广义的模块，它可能是子系统，可能是功能模块，也可能是功能模块中的某一个类。从不同的层次看，聚合的程度也会有所不同。至于为什么不同，后面会有解释。第三，模块的成分包括模块的行为和状态。要做到高聚合，那么模块内部的行为必须要与模块的内部状态紧密关联。通俗来讲，<strong>一个模块仅完成一个独立的功能，模块内部不存在与该功能无关的操作或状态。</strong></p>
<p>举一个生活中的例子。</p>
<p>有两座城市Sidtown和Fredborough，连接两座城市的公路一天到晚总是拥堵不堪。经过”有关部门”调查之后发现，这两座城市中有两家公司Better Mousetrap和 Zokko Soda，Better Mousetrap的工厂建造在Sidtown,而该工厂的员工都居住在Fredborough,所以每天早上大批员工从Fredborough出发前往Sidtown，并在傍晚返回；类似的，Zokko Soda公司的运输车在每天的工作时间都需要在制瓶工厂和灌装工厂穿梭来往。</p>
<p><img src="http://img.blog.csdn.net/20140326234013250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVtaXo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>很明显，如果Better Mousetrap的工厂和员工居住地都在同一城市，而Zokko Soda的两座工厂都建造在另一座城市，那么城市之间的交通状况将会明显改善。</p>
<p><img src="http://img.blog.csdn.net/20140326234049875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHVtaXo=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>对比两图，上面两座城市间之所以出现交通的问题，是因为每座城市的”聚合性”都比较低：不相关的两个公司出现在了同一座城市，使得城市内部交通的利用率比较低，而城市之间的交通出现了超负荷。</p>
<h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><blockquote>
<p>耦合（Couping）是模块之间相关联程度的度量</p>
</blockquote>
<p>相对于聚合的内向性，耦合关注的是某一模块和其他模块之间的关联性。其实从前面的例子里，我们已经不可避免的提到了耦合的问题：由于两座城市之间的相互联系过于紧密，导致了城市之间的交通拥堵。另外一个潜在的问题就是，如果其中一座城市内部的交通出现了问题，另一座城市也会受到影响。<strong>我们所追求的低耦合，就是将两个模块之间的关联尽可能的降低，一个模块发生变化对于其他模块的影响尽可能的小</strong>。</p>
<p>再讲一个生活中的例子，相信大部分的80后小的时候都玩过一种掌上游戏机，这种游戏机内含一个俄罗斯方块的游戏。这种游戏机虽然风靡一时，但是不多久就渐渐淡出了市场，因为这种游戏机只有俄罗斯方块可以玩儿，当我们玩儿腻了的时候，这个游戏机也就如同废物一个了。</p>
<p>同期，任天堂推出一款后来风靡了将近20年的红白机，这种游戏机市场寿命如此之长并非游戏机本身质量有多好，而是因为基于红白机开发的游戏层出不穷，经典无数。魂斗罗、超级玛丽在当时哪怕是现在也是无人不知。红白机的游戏本身并不存储在游戏机当中，每当有新游戏推出的时候，只需要购买新的卡带即可。正是这种游戏机和卡带相对独立的设计，使得游戏的设计厂商无需关心游戏机的实现细节，只要遵循游戏机提供的接口（插槽）。很多游戏的设计厂商也从红白机庞大的市场中分得一杯羹。大多数的玩家可能不知道，魂斗罗并非任天堂推出的产品，而是目前以《实况足球》系列闻名世界的KONAMI公司于1988年从街机移植到红白机上的。</p>
<p>回到耦合的话题上来，因为早先的掌上游戏机将游戏本身内置在机器当中，游戏和机器这两个模块之间的关系过于紧密，所以游戏玩儿腻了，游戏机就没用了，游戏机出问题了，游戏也再也不能玩儿了。而红白机的游戏和游戏机之间的关系是相对独立的，只要它们都遵循制定好的协议，就可以独立的发展和变化。游戏卡带摔坏了，其他的游戏一样可以在机器上运行；自己的游戏机坏了，把卡带拿到朋友家的游戏机上也能玩儿。红白机发展到后期，连游戏机的手柄也是可插拔的，如果手柄坏了，也只需要更换手柄即可</p>
<h4 id="编程运用"><a href="#编程运用" class="headerlink" title="编程运用"></a>编程运用</h4><p>前面曾经提到，从不同的层次看，聚合和耦合的程度也会有所不同。Sidtown和Fredborough的例子当中，从城市的层次来看，第二种设计完全达到了高内聚和低耦合的目标，然而，如果从城市的不同区域来看，这样的设计内聚性还不够。如果我们一直追究下去，恐怕Better Mousetrap所有的员工都要住在生产线上了。一味的追求高内聚，必然会造成模块的功能过于单一，而模块的数量出现急剧膨胀。所以，我们在设计和实现程序时必须要斟酌模块间的聚合和耦合程。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/03/12/面向对象/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2015/03/12/面向对象/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/03/12/面向对象/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-01-08T11:30:25.000Z"><a href="/2015/01/08/runtime/">Thu, Jan 8 2015, 7:30:25 pm</a></time>

  
    <h1 class="title"><a href="/2015/01/08/runtime/">runtime</a></h1>
  



<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <ol>
<li>动态语言VS静态语言<ul>
<li>c语言: 代码执行的逻辑在在编译的时候会决定好，编译完成之后直接顺序执行，无任何二义性</li>
<li>oc:它会尽可能地把代码执行的决策从编译和链接的时候，推迟到运行时。(关于编译和连接，参考这篇文章<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="external">编译器的工作过程</a><br>oc的动态性是依靠runtime 库实现的,runtime库是由c和汇编语言写成的。<br>runtime库主要做了下面几件事: </li>
</ul>
</li>
</ol>
<ul>
<li>封装:对象用C语言结构体表示，而方法可以用函数来实现，</li>
<li>找出方法最终执行的代码: </li>
</ul>
<p>####一个方法的旅程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line"></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line"></span><br><span class="line">    const char *name                        OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line"></span><br><span class="line">    long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line"></span><br><span class="line">    long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line"></span><br><span class="line">    long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line"></span><br><span class="line">    struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line"></span><br><span class="line">    struct objc_method_list *methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line"></span><br><span class="line">    struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存的链表</span><br><span class="line"></span><br><span class="line">    struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<ol>
<li>先解释一下参数的意义: </li>
</ol>
<p>SEL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL，<strong>这个类型本质是类方法的编号</strong>。</p>
<ul>
<li>SEL 和 IMP 就是我们上文提到的，所以我们可以理解为objc_class中 method list保存了一组SEL&lt;-&gt;IMP的映射。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20130718230259187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWl5YWFpeHVleGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>IMP的定义 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure>
<p>IMP本质是一个函数指针，我们可以通过SEL获得对应的IMP，获得IMP之后也意味着我们取得需要指向方法的代码入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...) &#123;</span><br><span class="line">    if (!self) return nil;</span><br><span class="line">	IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);</span><br><span class="line">	imp(self, op, ...); //调用这个函数，伪代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">//查找IMP</span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</span><br><span class="line"></span><br><span class="line">    if (!cls || !sel) return nil;</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel);</span><br><span class="line">   if (!imp) return _objc_msgForward; //这个是用于消息转发的</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel) &#123;</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;initialize()) &#123;</span><br><span class="line">        _class_initialize(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    Class curClass = cls;</span><br><span class="line"></span><br><span class="line">    IMP imp = nil;</span><br><span class="line"></span><br><span class="line">    do &#123; //先查缓存,缓存没有时重建,仍旧没有则向父类查询</span><br><span class="line"></span><br><span class="line">        if (!curClass) break;</span><br><span class="line"></span><br><span class="line">        if (!curClass-&gt;cache) fill_cache(cls, curClass);</span><br><span class="line"></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line"></span><br><span class="line">        if (imp) break;</span><br><span class="line"></span><br><span class="line">    &#125; while (curClass = curClass-&gt;superclass);</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以梳理出相关方法的执行过程: </p>
<ol>
<li><p>检查receiver是否为nil，如果为nil，直接return(这也是为什么我们向一个nil发送消息不会crash)</p>
</li>
<li><p>根据receiver 内部的iSA指针找到它所指向的类对象，然后再根据SEL查询IMP </p>
<ul>
<li>先查询cache 方法链表</li>
<li>再从methodList查找</li>
<li>还没找到，就沿着继承体系向上查找，一直找到NSObject</li>
<li>如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替imp。_objc_msgForward的作用是在程序抛出<em>unrecognized selector sent to</em> 之前调用消息转发的方法，让你有机会拯救程序</li>
</ul>
</li>
<li><p>消息转发阶段: </p>
<ul>
<li><p>Method resolution: 调用 <code>+resolveInstanceMethod:</code> 或者 <code>+resolveClassMethod:</code>，让你有机会提供一个函数实现。如果你添加了函数并返回 YES</p>
</li>
<li><p>fast forwarding: 调用这个方法，给你把这个消息转发给其他对象的机会,如果获取到，直接转发给它。如果返回nil，继续下面操作</p>
</li>
<li><p>Normal forwarding :这一步是 Runtime 最后一次给你挽救的机会。运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息 有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation 方法中选择将消息转发给其它对象。</p>
</li>
</ul>
</li>
</ol>
<h3 id="iVar变量"><a href="#iVar变量" class="headerlink" title="iVar变量"></a>iVar变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name      // 变量名                                    </span><br><span class="line">    char *ivar_type      // 变量类型                                    </span><br><span class="line">    int ivar_offset      // 基地址偏移字节                                    </span><br><span class="line"> #ifdef __LP64__</span><br><span class="line">    int space                                                </span><br><span class="line"> #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关参考文档: </p>
<p><a href="http://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="external">Objective-C 中的消息与消息转发</a></p>
<p><a href="http://www.cocoachina.com/ios/20150604/12013.html" target="_blank" rel="external">轻松学习之 Objective-C消息转发</a></p>
<p><a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a></p>
<p><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="external">Objective-C Runtime 运行时之一：类与对象</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/01/08/runtime/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="atony2099.github.io/2015/01/08/runtime/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/01/08/runtime/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev"><i class="fa fa-long-arrow-left"></i>Vorherige Seite</a>
  
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js"></script>
<script src="/js/cover.js"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2016 tony2009
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"your_id"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>